
EmbeddedSystems.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  000012d4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001260  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000010  00800100  00800100  000012d4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000012d4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001304  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000168  00000000  00000000  00001344  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001328  00000000  00000000  000014ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000008b0  00000000  00000000  000027d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000d63  00000000  00000000  00003084  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000444  00000000  00000000  00003de8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000549  00000000  00000000  0000422c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000079e  00000000  00000000  00004775  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001c8  00000000  00000000  00004f13  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	33 c0       	rjmp	.+102    	; 0x68 <__ctors_end>
       2:	00 00       	nop
       4:	42 c0       	rjmp	.+132    	; 0x8a <__bad_interrupt>
       6:	00 00       	nop
       8:	40 c0       	rjmp	.+128    	; 0x8a <__bad_interrupt>
       a:	00 00       	nop
       c:	3e c0       	rjmp	.+124    	; 0x8a <__bad_interrupt>
       e:	00 00       	nop
      10:	3c c0       	rjmp	.+120    	; 0x8a <__bad_interrupt>
      12:	00 00       	nop
      14:	3a c0       	rjmp	.+116    	; 0x8a <__bad_interrupt>
      16:	00 00       	nop
      18:	38 c0       	rjmp	.+112    	; 0x8a <__bad_interrupt>
      1a:	00 00       	nop
      1c:	36 c0       	rjmp	.+108    	; 0x8a <__bad_interrupt>
      1e:	00 00       	nop
      20:	34 c0       	rjmp	.+104    	; 0x8a <__bad_interrupt>
      22:	00 00       	nop
      24:	32 c0       	rjmp	.+100    	; 0x8a <__bad_interrupt>
      26:	00 00       	nop
      28:	30 c0       	rjmp	.+96     	; 0x8a <__bad_interrupt>
      2a:	00 00       	nop
      2c:	2e c0       	rjmp	.+92     	; 0x8a <__bad_interrupt>
      2e:	00 00       	nop
      30:	2c c0       	rjmp	.+88     	; 0x8a <__bad_interrupt>
      32:	00 00       	nop
      34:	2a c0       	rjmp	.+84     	; 0x8a <__bad_interrupt>
      36:	00 00       	nop
      38:	28 c0       	rjmp	.+80     	; 0x8a <__bad_interrupt>
      3a:	00 00       	nop
      3c:	26 c0       	rjmp	.+76     	; 0x8a <__bad_interrupt>
      3e:	00 00       	nop
      40:	6f c1       	rjmp	.+734    	; 0x320 <__vector_16>
      42:	00 00       	nop
      44:	22 c0       	rjmp	.+68     	; 0x8a <__bad_interrupt>
      46:	00 00       	nop
      48:	20 c0       	rjmp	.+64     	; 0x8a <__bad_interrupt>
      4a:	00 00       	nop
      4c:	1e c0       	rjmp	.+60     	; 0x8a <__bad_interrupt>
      4e:	00 00       	nop
      50:	1c c0       	rjmp	.+56     	; 0x8a <__bad_interrupt>
      52:	00 00       	nop
      54:	1a c0       	rjmp	.+52     	; 0x8a <__bad_interrupt>
      56:	00 00       	nop
      58:	18 c0       	rjmp	.+48     	; 0x8a <__bad_interrupt>
      5a:	00 00       	nop
      5c:	16 c0       	rjmp	.+44     	; 0x8a <__bad_interrupt>
      5e:	00 00       	nop
      60:	14 c0       	rjmp	.+40     	; 0x8a <__bad_interrupt>
      62:	00 00       	nop
      64:	12 c0       	rjmp	.+36     	; 0x8a <__bad_interrupt>
	...

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_clear_bss>:
      74:	21 e0       	ldi	r18, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	01 c0       	rjmp	.+2      	; 0x7e <.do_clear_bss_start>

0000007c <.do_clear_bss_loop>:
      7c:	1d 92       	st	X+, r1

0000007e <.do_clear_bss_start>:
      7e:	a0 31       	cpi	r26, 0x10	; 16
      80:	b2 07       	cpc	r27, r18
      82:	e1 f7       	brne	.-8      	; 0x7c <.do_clear_bss_loop>
      84:	6d d1       	rcall	.+730    	; 0x360 <main>
      86:	0c 94 2e 09 	jmp	0x125c	; 0x125c <_exit>

0000008a <__bad_interrupt>:
      8a:	ba cf       	rjmp	.-140    	; 0x0 <__vectors>

0000008c <Led_init>:
void Led7_On(void) {
    PORTB |= (1 << 1);
}
void Led7_Off(void) {
    PORTB &= ~(1 << 1);
}
      8c:	cf 93       	push	r28
      8e:	df 93       	push	r29
      90:	cd b7       	in	r28, 0x3d	; 61
      92:	de b7       	in	r29, 0x3e	; 62
      94:	84 e2       	ldi	r24, 0x24	; 36
      96:	90 e0       	ldi	r25, 0x00	; 0
      98:	2f ef       	ldi	r18, 0xFF	; 255
      9a:	fc 01       	movw	r30, r24
      9c:	20 83       	st	Z, r18
      9e:	85 e2       	ldi	r24, 0x25	; 37
      a0:	90 e0       	ldi	r25, 0x00	; 0
      a2:	fc 01       	movw	r30, r24
      a4:	10 82       	st	Z, r1
      a6:	00 00       	nop
      a8:	df 91       	pop	r29
      aa:	cf 91       	pop	r28
      ac:	08 95       	ret

000000ae <Led1_On>:
      ae:	cf 93       	push	r28
      b0:	df 93       	push	r29
      b2:	cd b7       	in	r28, 0x3d	; 61
      b4:	de b7       	in	r29, 0x3e	; 62
      b6:	85 e2       	ldi	r24, 0x25	; 37
      b8:	90 e0       	ldi	r25, 0x00	; 0
      ba:	25 e2       	ldi	r18, 0x25	; 37
      bc:	30 e0       	ldi	r19, 0x00	; 0
      be:	f9 01       	movw	r30, r18
      c0:	20 81       	ld	r18, Z
      c2:	20 68       	ori	r18, 0x80	; 128
      c4:	fc 01       	movw	r30, r24
      c6:	20 83       	st	Z, r18
      c8:	00 00       	nop
      ca:	df 91       	pop	r29
      cc:	cf 91       	pop	r28
      ce:	08 95       	ret

000000d0 <Led1_Off>:
      d0:	cf 93       	push	r28
      d2:	df 93       	push	r29
      d4:	cd b7       	in	r28, 0x3d	; 61
      d6:	de b7       	in	r29, 0x3e	; 62
      d8:	85 e2       	ldi	r24, 0x25	; 37
      da:	90 e0       	ldi	r25, 0x00	; 0
      dc:	25 e2       	ldi	r18, 0x25	; 37
      de:	30 e0       	ldi	r19, 0x00	; 0
      e0:	f9 01       	movw	r30, r18
      e2:	20 81       	ld	r18, Z
      e4:	2f 77       	andi	r18, 0x7F	; 127
      e6:	fc 01       	movw	r30, r24
      e8:	20 83       	st	Z, r18
      ea:	00 00       	nop
      ec:	df 91       	pop	r29
      ee:	cf 91       	pop	r28
      f0:	08 95       	ret

000000f2 <Led2_On>:
      f2:	cf 93       	push	r28
      f4:	df 93       	push	r29
      f6:	cd b7       	in	r28, 0x3d	; 61
      f8:	de b7       	in	r29, 0x3e	; 62
      fa:	85 e2       	ldi	r24, 0x25	; 37
      fc:	90 e0       	ldi	r25, 0x00	; 0
      fe:	25 e2       	ldi	r18, 0x25	; 37
     100:	30 e0       	ldi	r19, 0x00	; 0
     102:	f9 01       	movw	r30, r18
     104:	20 81       	ld	r18, Z
     106:	20 64       	ori	r18, 0x40	; 64
     108:	fc 01       	movw	r30, r24
     10a:	20 83       	st	Z, r18
     10c:	00 00       	nop
     10e:	df 91       	pop	r29
     110:	cf 91       	pop	r28
     112:	08 95       	ret

00000114 <Led2_Off>:
     114:	cf 93       	push	r28
     116:	df 93       	push	r29
     118:	cd b7       	in	r28, 0x3d	; 61
     11a:	de b7       	in	r29, 0x3e	; 62
     11c:	85 e2       	ldi	r24, 0x25	; 37
     11e:	90 e0       	ldi	r25, 0x00	; 0
     120:	25 e2       	ldi	r18, 0x25	; 37
     122:	30 e0       	ldi	r19, 0x00	; 0
     124:	f9 01       	movw	r30, r18
     126:	20 81       	ld	r18, Z
     128:	2f 7b       	andi	r18, 0xBF	; 191
     12a:	fc 01       	movw	r30, r24
     12c:	20 83       	st	Z, r18
     12e:	00 00       	nop
     130:	df 91       	pop	r29
     132:	cf 91       	pop	r28
     134:	08 95       	ret

00000136 <Led3_On>:
     136:	cf 93       	push	r28
     138:	df 93       	push	r29
     13a:	cd b7       	in	r28, 0x3d	; 61
     13c:	de b7       	in	r29, 0x3e	; 62
     13e:	85 e2       	ldi	r24, 0x25	; 37
     140:	90 e0       	ldi	r25, 0x00	; 0
     142:	25 e2       	ldi	r18, 0x25	; 37
     144:	30 e0       	ldi	r19, 0x00	; 0
     146:	f9 01       	movw	r30, r18
     148:	20 81       	ld	r18, Z
     14a:	20 62       	ori	r18, 0x20	; 32
     14c:	fc 01       	movw	r30, r24
     14e:	20 83       	st	Z, r18
     150:	00 00       	nop
     152:	df 91       	pop	r29
     154:	cf 91       	pop	r28
     156:	08 95       	ret

00000158 <Led3_Off>:
     158:	cf 93       	push	r28
     15a:	df 93       	push	r29
     15c:	cd b7       	in	r28, 0x3d	; 61
     15e:	de b7       	in	r29, 0x3e	; 62
     160:	85 e2       	ldi	r24, 0x25	; 37
     162:	90 e0       	ldi	r25, 0x00	; 0
     164:	25 e2       	ldi	r18, 0x25	; 37
     166:	30 e0       	ldi	r19, 0x00	; 0
     168:	f9 01       	movw	r30, r18
     16a:	20 81       	ld	r18, Z
     16c:	2f 7d       	andi	r18, 0xDF	; 223
     16e:	fc 01       	movw	r30, r24
     170:	20 83       	st	Z, r18
     172:	00 00       	nop
     174:	df 91       	pop	r29
     176:	cf 91       	pop	r28
     178:	08 95       	ret

0000017a <Led4_On>:
     17a:	cf 93       	push	r28
     17c:	df 93       	push	r29
     17e:	cd b7       	in	r28, 0x3d	; 61
     180:	de b7       	in	r29, 0x3e	; 62
     182:	85 e2       	ldi	r24, 0x25	; 37
     184:	90 e0       	ldi	r25, 0x00	; 0
     186:	25 e2       	ldi	r18, 0x25	; 37
     188:	30 e0       	ldi	r19, 0x00	; 0
     18a:	f9 01       	movw	r30, r18
     18c:	20 81       	ld	r18, Z
     18e:	20 61       	ori	r18, 0x10	; 16
     190:	fc 01       	movw	r30, r24
     192:	20 83       	st	Z, r18
     194:	00 00       	nop
     196:	df 91       	pop	r29
     198:	cf 91       	pop	r28
     19a:	08 95       	ret

0000019c <Led4_Off>:
     19c:	cf 93       	push	r28
     19e:	df 93       	push	r29
     1a0:	cd b7       	in	r28, 0x3d	; 61
     1a2:	de b7       	in	r29, 0x3e	; 62
     1a4:	85 e2       	ldi	r24, 0x25	; 37
     1a6:	90 e0       	ldi	r25, 0x00	; 0
     1a8:	25 e2       	ldi	r18, 0x25	; 37
     1aa:	30 e0       	ldi	r19, 0x00	; 0
     1ac:	f9 01       	movw	r30, r18
     1ae:	20 81       	ld	r18, Z
     1b0:	2f 7e       	andi	r18, 0xEF	; 239
     1b2:	fc 01       	movw	r30, r24
     1b4:	20 83       	st	Z, r18
     1b6:	00 00       	nop
     1b8:	df 91       	pop	r29
     1ba:	cf 91       	pop	r28
     1bc:	08 95       	ret

000001be <Led5_On>:
     1be:	cf 93       	push	r28
     1c0:	df 93       	push	r29
     1c2:	cd b7       	in	r28, 0x3d	; 61
     1c4:	de b7       	in	r29, 0x3e	; 62
     1c6:	85 e2       	ldi	r24, 0x25	; 37
     1c8:	90 e0       	ldi	r25, 0x00	; 0
     1ca:	25 e2       	ldi	r18, 0x25	; 37
     1cc:	30 e0       	ldi	r19, 0x00	; 0
     1ce:	f9 01       	movw	r30, r18
     1d0:	20 81       	ld	r18, Z
     1d2:	28 60       	ori	r18, 0x08	; 8
     1d4:	fc 01       	movw	r30, r24
     1d6:	20 83       	st	Z, r18
     1d8:	00 00       	nop
     1da:	df 91       	pop	r29
     1dc:	cf 91       	pop	r28
     1de:	08 95       	ret

000001e0 <Led8_On>:

/**
led8 - ioB0
*/
void Led8_On(void) {
     1e0:	cf 93       	push	r28
     1e2:	df 93       	push	r29
     1e4:	cd b7       	in	r28, 0x3d	; 61
     1e6:	de b7       	in	r29, 0x3e	; 62
    PORTB |= (1 << 0);
     1e8:	85 e2       	ldi	r24, 0x25	; 37
     1ea:	90 e0       	ldi	r25, 0x00	; 0
     1ec:	25 e2       	ldi	r18, 0x25	; 37
     1ee:	30 e0       	ldi	r19, 0x00	; 0
     1f0:	f9 01       	movw	r30, r18
     1f2:	20 81       	ld	r18, Z
     1f4:	21 60       	ori	r18, 0x01	; 1
     1f6:	fc 01       	movw	r30, r24
     1f8:	20 83       	st	Z, r18
}
     1fa:	00 00       	nop
     1fc:	df 91       	pop	r29
     1fe:	cf 91       	pop	r28
     200:	08 95       	ret

00000202 <Taster_init>:
 ---------------------
 - DDR Reg has to be set to 0
 - PORT Reg has to be set to 1
 -> Pin is input with pull-up
 */
void Taster_init() {
     202:	cf 93       	push	r28
     204:	df 93       	push	r29
     206:	cd b7       	in	r28, 0x3d	; 61
     208:	de b7       	in	r29, 0x3e	; 62
    // set to inputs
    DDRC &= ~(1 << 2);
     20a:	87 e2       	ldi	r24, 0x27	; 39
     20c:	90 e0       	ldi	r25, 0x00	; 0
     20e:	27 e2       	ldi	r18, 0x27	; 39
     210:	30 e0       	ldi	r19, 0x00	; 0
     212:	f9 01       	movw	r30, r18
     214:	20 81       	ld	r18, Z
     216:	2b 7f       	andi	r18, 0xFB	; 251
     218:	fc 01       	movw	r30, r24
     21a:	20 83       	st	Z, r18
    DDRD &= ~( (1 << 7) | (1 << 6) | (1 << 5) );
     21c:	8a e2       	ldi	r24, 0x2A	; 42
     21e:	90 e0       	ldi	r25, 0x00	; 0
     220:	2a e2       	ldi	r18, 0x2A	; 42
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	f9 01       	movw	r30, r18
     226:	20 81       	ld	r18, Z
     228:	2f 71       	andi	r18, 0x1F	; 31
     22a:	fc 01       	movw	r30, r24
     22c:	20 83       	st	Z, r18
    
    // enable pull-up
    PORTC |= (1 << 2);
     22e:	88 e2       	ldi	r24, 0x28	; 40
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	28 e2       	ldi	r18, 0x28	; 40
     234:	30 e0       	ldi	r19, 0x00	; 0
     236:	f9 01       	movw	r30, r18
     238:	20 81       	ld	r18, Z
     23a:	24 60       	ori	r18, 0x04	; 4
     23c:	fc 01       	movw	r30, r24
     23e:	20 83       	st	Z, r18
    PORTD |= (1 << 7) | (1 << 6) | (1 << 5);
     240:	8b e2       	ldi	r24, 0x2B	; 43
     242:	90 e0       	ldi	r25, 0x00	; 0
     244:	2b e2       	ldi	r18, 0x2B	; 43
     246:	30 e0       	ldi	r19, 0x00	; 0
     248:	f9 01       	movw	r30, r18
     24a:	20 81       	ld	r18, Z
     24c:	20 6e       	ori	r18, 0xE0	; 224
     24e:	fc 01       	movw	r30, r24
     250:	20 83       	st	Z, r18
}
     252:	00 00       	nop
     254:	df 91       	pop	r29
     256:	cf 91       	pop	r28
     258:	08 95       	ret

0000025a <Taster1_get>:

/**
 Taster1 - ioD7
 */
uint8_t Taster1_get(void) {
     25a:	cf 93       	push	r28
     25c:	df 93       	push	r29
     25e:	00 d0       	rcall	.+0      	; 0x260 <Taster1_get+0x6>
     260:	cd b7       	in	r28, 0x3d	; 61
     262:	de b7       	in	r29, 0x3e	; 62
    int state = PIND;
     264:	89 e2       	ldi	r24, 0x29	; 41
     266:	90 e0       	ldi	r25, 0x00	; 0
     268:	fc 01       	movw	r30, r24
     26a:	80 81       	ld	r24, Z
     26c:	88 2f       	mov	r24, r24
     26e:	90 e0       	ldi	r25, 0x00	; 0
     270:	9a 83       	std	Y+2, r25	; 0x02
     272:	89 83       	std	Y+1, r24	; 0x01
    if ( (state & (1<<7)) == 0 ) {
     274:	89 81       	ldd	r24, Y+1	; 0x01
     276:	9a 81       	ldd	r25, Y+2	; 0x02
     278:	80 78       	andi	r24, 0x80	; 128
     27a:	99 27       	eor	r25, r25
     27c:	89 2b       	or	r24, r25
     27e:	11 f4       	brne	.+4      	; 0x284 <Taster1_get+0x2a>
        return TASTER_RETURN_VALUE_LOW;
     280:	81 e0       	ldi	r24, 0x01	; 1
     282:	01 c0       	rjmp	.+2      	; 0x286 <Taster1_get+0x2c>
    } else {
        return TASTER_RETURN_VALUE_HIGH;
     284:	80 e0       	ldi	r24, 0x00	; 0
    }
}
     286:	0f 90       	pop	r0
     288:	0f 90       	pop	r0
     28a:	df 91       	pop	r29
     28c:	cf 91       	pop	r28
     28e:	08 95       	ret

00000290 <Taster2_get>:

/**
Taster2 - ioD6
*/
uint8_t Taster2_get(void) {
     290:	cf 93       	push	r28
     292:	df 93       	push	r29
     294:	1f 92       	push	r1
     296:	cd b7       	in	r28, 0x3d	; 61
     298:	de b7       	in	r29, 0x3e	; 62
    uint8_t state = PIND;
     29a:	89 e2       	ldi	r24, 0x29	; 41
     29c:	90 e0       	ldi	r25, 0x00	; 0
     29e:	fc 01       	movw	r30, r24
     2a0:	80 81       	ld	r24, Z
     2a2:	89 83       	std	Y+1, r24	; 0x01
    if ( (state & (1<<6)) == 0 ) {
     2a4:	89 81       	ldd	r24, Y+1	; 0x01
     2a6:	88 2f       	mov	r24, r24
     2a8:	90 e0       	ldi	r25, 0x00	; 0
     2aa:	80 74       	andi	r24, 0x40	; 64
     2ac:	99 27       	eor	r25, r25
     2ae:	89 2b       	or	r24, r25
     2b0:	11 f4       	brne	.+4      	; 0x2b6 <Taster2_get+0x26>
        return TASTER_RETURN_VALUE_LOW;
     2b2:	81 e0       	ldi	r24, 0x01	; 1
     2b4:	01 c0       	rjmp	.+2      	; 0x2b8 <Taster2_get+0x28>
    } else {
        return TASTER_RETURN_VALUE_HIGH;
     2b6:	80 e0       	ldi	r24, 0x00	; 0
    }
}
     2b8:	0f 90       	pop	r0
     2ba:	df 91       	pop	r29
     2bc:	cf 91       	pop	r28
     2be:	08 95       	ret

000002c0 <Taster3_get>:

/**
Taster3 - ioD5
*/
uint8_t Taster3_get(void) {
     2c0:	cf 93       	push	r28
     2c2:	df 93       	push	r29
     2c4:	1f 92       	push	r1
     2c6:	cd b7       	in	r28, 0x3d	; 61
     2c8:	de b7       	in	r29, 0x3e	; 62
    uint8_t state = PIND;
     2ca:	89 e2       	ldi	r24, 0x29	; 41
     2cc:	90 e0       	ldi	r25, 0x00	; 0
     2ce:	fc 01       	movw	r30, r24
     2d0:	80 81       	ld	r24, Z
     2d2:	89 83       	std	Y+1, r24	; 0x01
    if ( (state & (1<<5)) == 0 ) {
     2d4:	89 81       	ldd	r24, Y+1	; 0x01
     2d6:	88 2f       	mov	r24, r24
     2d8:	90 e0       	ldi	r25, 0x00	; 0
     2da:	80 72       	andi	r24, 0x20	; 32
     2dc:	99 27       	eor	r25, r25
     2de:	89 2b       	or	r24, r25
     2e0:	11 f4       	brne	.+4      	; 0x2e6 <Taster3_get+0x26>
        return TASTER_RETURN_VALUE_LOW;
     2e2:	81 e0       	ldi	r24, 0x01	; 1
     2e4:	01 c0       	rjmp	.+2      	; 0x2e8 <Taster3_get+0x28>
    } else {
        return TASTER_RETURN_VALUE_HIGH;
     2e6:	80 e0       	ldi	r24, 0x00	; 0
    }
}
     2e8:	0f 90       	pop	r0
     2ea:	df 91       	pop	r29
     2ec:	cf 91       	pop	r28
     2ee:	08 95       	ret

000002f0 <Taster4_get>:

/**
Taster4 - ioC2
*/
uint8_t Taster4_get(void) {
     2f0:	cf 93       	push	r28
     2f2:	df 93       	push	r29
     2f4:	1f 92       	push	r1
     2f6:	cd b7       	in	r28, 0x3d	; 61
     2f8:	de b7       	in	r29, 0x3e	; 62
    uint8_t state = PINC;
     2fa:	86 e2       	ldi	r24, 0x26	; 38
     2fc:	90 e0       	ldi	r25, 0x00	; 0
     2fe:	fc 01       	movw	r30, r24
     300:	80 81       	ld	r24, Z
     302:	89 83       	std	Y+1, r24	; 0x01
    if ( (state & (1<<2)) == 0 ) {
     304:	89 81       	ldd	r24, Y+1	; 0x01
     306:	88 2f       	mov	r24, r24
     308:	90 e0       	ldi	r25, 0x00	; 0
     30a:	84 70       	andi	r24, 0x04	; 4
     30c:	99 27       	eor	r25, r25
     30e:	89 2b       	or	r24, r25
     310:	11 f4       	brne	.+4      	; 0x316 <Taster4_get+0x26>
        return TASTER_RETURN_VALUE_LOW;
     312:	81 e0       	ldi	r24, 0x01	; 1
     314:	01 c0       	rjmp	.+2      	; 0x318 <Taster4_get+0x28>
    } else {
        return TASTER_RETURN_VALUE_HIGH;
     316:	80 e0       	ldi	r24, 0x00	; 0
    }
}
     318:	0f 90       	pop	r0
     31a:	df 91       	pop	r29
     31c:	cf 91       	pop	r28
     31e:	08 95       	ret

00000320 <__vector_16>:


volatile uint16_t x = 0;


ISR(TIMER0_OVF_vect){
     320:	1f 92       	push	r1
     322:	0f 92       	push	r0
     324:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
     328:	0f 92       	push	r0
     32a:	11 24       	eor	r1, r1
     32c:	8f 93       	push	r24
     32e:	9f 93       	push	r25
     330:	cf 93       	push	r28
     332:	df 93       	push	r29
     334:	cd b7       	in	r28, 0x3d	; 61
     336:	de b7       	in	r29, 0x3e	; 62
    x++;
     338:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
     33c:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <_edata+0x1>
     340:	01 96       	adiw	r24, 0x01	; 1
     342:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <_edata+0x1>
     346:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
}
     34a:	00 00       	nop
     34c:	df 91       	pop	r29
     34e:	cf 91       	pop	r28
     350:	9f 91       	pop	r25
     352:	8f 91       	pop	r24
     354:	0f 90       	pop	r0
     356:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
     35a:	0f 90       	pop	r0
     35c:	1f 90       	pop	r1
     35e:	18 95       	reti

00000360 <main>:


int main(void) {
     360:	cf 93       	push	r28
     362:	df 93       	push	r29
     364:	cd b7       	in	r28, 0x3d	; 61
     366:	de b7       	in	r29, 0x3e	; 62
	
    Led_init();
     368:	91 de       	rcall	.-734    	; 0x8c <Led_init>
	Taster_init();
     36a:	4b df       	rcall	.-362    	; 0x202 <Taster_init>
    Timer_init();
     36c:	49 d6       	rcall	.+3218   	; 0x1000 <Timer_init>
	sei();
     36e:	78 94       	sei
	
    while (1) {
        playground();
     370:	0c d0       	rcall	.+24     	; 0x38a <playground>
     372:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
        if ( x > 1000) {
     376:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <_edata+0x1>
     37a:	89 3e       	cpi	r24, 0xE9	; 233
     37c:	93 40       	sbci	r25, 0x03	; 3
     37e:	c0 f3       	brcs	.-16     	; 0x370 <main+0x10>
     380:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <_edata+0x1>
            x = 0;
     384:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <_edata>
     388:	f3 cf       	rjmp	.-26     	; 0x370 <main+0x10>

0000038a <playground>:
        }
    }
     38a:	0f 93       	push	r16
- button1 pressed -> testTasterLed()
- button2 pressed -> testBoard()
- button3 pressed -> lauflicht()
- button4 pressed -> increment()
*/
void playground() {
     38c:	1f 93       	push	r17
     38e:	cf 93       	push	r28
     390:	df 93       	push	r29
     392:	cd b7       	in	r28, 0x3d	; 61
     394:	de b7       	in	r29, 0x3e	; 62
     396:	c4 55       	subi	r28, 0x54	; 84
     398:	d1 09       	sbc	r29, r1
     39a:	0f b6       	in	r0, 0x3f	; 63
     39c:	f8 94       	cli
     39e:	de bf       	out	0x3e, r29	; 62
     3a0:	0f be       	out	0x3f, r0	; 63
     3a2:	cd bf       	out	0x3d, r28	; 61
    static int mode = 0;
    
    if (mode == 0) {    // mode selection
     3a4:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <mode.1739>
     3a8:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <mode.1739+0x1>
     3ac:	89 2b       	or	r24, r25
     3ae:	09 f0       	breq	.+2      	; 0x3b2 <playground+0x28>
     3b0:	02 c2       	rjmp	.+1028   	; 0x7b6 <__LOCK_REGION_LENGTH__+0x3b6>
        Led1_On();
     3b2:	7d de       	rcall	.-774    	; 0xae <Led1_On>
        Led4_On();
     3b4:	e2 de       	rcall	.-572    	; 0x17a <Led4_On>
        Led5_On();
     3b6:	03 df       	rcall	.-506    	; 0x1be <Led5_On>
        Led8_On();
     3b8:	13 df       	rcall	.-474    	; 0x1e0 <Led8_On>
     3ba:	4f df       	rcall	.-354    	; 0x25a <Taster1_get>
        
        // test buttons
        if (Taster1_get()) {
     3bc:	89 2b       	or	r24, r25
     3be:	09 f4       	brne	.+2      	; 0x3c2 <playground+0x38>
     3c0:	79 c0       	rjmp	.+242    	; 0x4b4 <__LOCK_REGION_LENGTH__+0xb4>
     3c2:	81 e0       	ldi	r24, 0x01	; 1
     3c4:	90 e0       	ldi	r25, 0x00	; 0
            mode = 1;
     3c6:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <mode.1739+0x1>
     3ca:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <mode.1739>
     3ce:	85 e2       	ldi	r24, 0x25	; 37
            PORTB = 0x00;
     3d0:	90 e0       	ldi	r25, 0x00	; 0
     3d2:	fc 01       	movw	r30, r24
     3d4:	10 82       	st	Z, r1
     3d6:	6b de       	rcall	.-810    	; 0xae <Led1_On>
            Led1_On();
     3d8:	80 e0       	ldi	r24, 0x00	; 0
     3da:	90 e0       	ldi	r25, 0x00	; 0
     3dc:	aa ef       	ldi	r26, 0xFA	; 250
     3de:	b3 e4       	ldi	r27, 0x43	; 67
     3e0:	8d 8b       	std	Y+21, r24	; 0x15
     3e2:	9e 8b       	std	Y+22, r25	; 0x16
     3e4:	af 8b       	std	Y+23, r26	; 0x17
     3e6:	b8 8f       	std	Y+24, r27	; 0x18
     3e8:	20 e0       	ldi	r18, 0x00	; 0
     3ea:	30 e0       	ldi	r19, 0x00	; 0

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     3ec:	4a e7       	ldi	r20, 0x7A	; 122
     3ee:	53 e4       	ldi	r21, 0x43	; 67
     3f0:	6d 89       	ldd	r22, Y+21	; 0x15
     3f2:	7e 89       	ldd	r23, Y+22	; 0x16
     3f4:	8f 89       	ldd	r24, Y+23	; 0x17
     3f6:	98 8d       	ldd	r25, Y+24	; 0x18
     3f8:	a6 d6       	rcall	.+3404   	; 0x1146 <__mulsf3>
     3fa:	dc 01       	movw	r26, r24
     3fc:	cb 01       	movw	r24, r22
     3fe:	89 8f       	std	Y+25, r24	; 0x19
     400:	9a 8f       	std	Y+26, r25	; 0x1a
     402:	ab 8f       	std	Y+27, r26	; 0x1b
     404:	bc 8f       	std	Y+28, r27	; 0x1c
     406:	20 e0       	ldi	r18, 0x00	; 0
     408:	30 e0       	ldi	r19, 0x00	; 0
	if (__tmp < 1.0)
     40a:	40 e8       	ldi	r20, 0x80	; 128
     40c:	5f e3       	ldi	r21, 0x3F	; 63
     40e:	69 8d       	ldd	r22, Y+25	; 0x19
     410:	7a 8d       	ldd	r23, Y+26	; 0x1a
     412:	8b 8d       	ldd	r24, Y+27	; 0x1b
     414:	9c 8d       	ldd	r25, Y+28	; 0x1c
     416:	16 d6       	rcall	.+3116   	; 0x1044 <__cmpsf2>
     418:	88 23       	and	r24, r24
     41a:	2c f4       	brge	.+10     	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
     41c:	81 e0       	ldi	r24, 0x01	; 1
     41e:	90 e0       	ldi	r25, 0x00	; 0
		__ticks = 1;
     420:	9e 8f       	std	Y+30, r25	; 0x1e
     422:	8d 8f       	std	Y+29, r24	; 0x1d
     424:	3b c0       	rjmp	.+118    	; 0x49c <__LOCK_REGION_LENGTH__+0x9c>
     426:	20 e0       	ldi	r18, 0x00	; 0
     428:	3f ef       	ldi	r19, 0xFF	; 255
	else if (__tmp > 65535)
     42a:	4f e7       	ldi	r20, 0x7F	; 127
     42c:	57 e4       	ldi	r21, 0x47	; 71
     42e:	69 8d       	ldd	r22, Y+25	; 0x19
     430:	7a 8d       	ldd	r23, Y+26	; 0x1a
     432:	8b 8d       	ldd	r24, Y+27	; 0x1b
     434:	9c 8d       	ldd	r25, Y+28	; 0x1c
     436:	83 d6       	rcall	.+3334   	; 0x113e <__gesf2>
     438:	18 16       	cp	r1, r24
     43a:	3c f5       	brge	.+78     	; 0x48a <__LOCK_REGION_LENGTH__+0x8a>
     43c:	20 e0       	ldi	r18, 0x00	; 0
     43e:	30 e0       	ldi	r19, 0x00	; 0
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     440:	40 e2       	ldi	r20, 0x20	; 32
     442:	51 e4       	ldi	r21, 0x41	; 65
     444:	6d 89       	ldd	r22, Y+21	; 0x15
     446:	7e 89       	ldd	r23, Y+22	; 0x16
     448:	8f 89       	ldd	r24, Y+23	; 0x17
     44a:	98 8d       	ldd	r25, Y+24	; 0x18
     44c:	7c d6       	rcall	.+3320   	; 0x1146 <__mulsf3>
     44e:	dc 01       	movw	r26, r24
     450:	cb 01       	movw	r24, r22
     452:	bc 01       	movw	r22, r24
     454:	cd 01       	movw	r24, r26
     456:	fa d5       	rcall	.+3060   	; 0x104c <__fixunssfsi>
     458:	dc 01       	movw	r26, r24
     45a:	cb 01       	movw	r24, r22
     45c:	9e 8f       	std	Y+30, r25	; 0x1e
     45e:	8d 8f       	std	Y+29, r24	; 0x1d
     460:	0f c0       	rjmp	.+30     	; 0x480 <__LOCK_REGION_LENGTH__+0x80>
     462:	89 e1       	ldi	r24, 0x19	; 25
     464:	90 e0       	ldi	r25, 0x00	; 0
     466:	98 a3       	std	Y+32, r25	; 0x20
     468:	8f 8f       	std	Y+31, r24	; 0x1f
     46a:	8f 8d       	ldd	r24, Y+31	; 0x1f
     46c:	98 a1       	ldd	r25, Y+32	; 0x20
     46e:	01 97       	sbiw	r24, 0x01	; 1
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     470:	f1 f7       	brne	.-4      	; 0x46e <__LOCK_REGION_LENGTH__+0x6e>
     472:	98 a3       	std	Y+32, r25	; 0x20
     474:	8f 8f       	std	Y+31, r24	; 0x1f
     476:	8d 8d       	ldd	r24, Y+29	; 0x1d
     478:	9e 8d       	ldd	r25, Y+30	; 0x1e
     47a:	01 97       	sbiw	r24, 0x01	; 1
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     47c:	9e 8f       	std	Y+30, r25	; 0x1e
     47e:	8d 8f       	std	Y+29, r24	; 0x1d
     480:	8d 8d       	ldd	r24, Y+29	; 0x1d
     482:	9e 8d       	ldd	r25, Y+30	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     484:	89 2b       	or	r24, r25
     486:	69 f7       	brne	.-38     	; 0x462 <__LOCK_REGION_LENGTH__+0x62>
     488:	13 c0       	rjmp	.+38     	; 0x4b0 <__LOCK_REGION_LENGTH__+0xb0>
     48a:	69 8d       	ldd	r22, Y+25	; 0x19
     48c:	7a 8d       	ldd	r23, Y+26	; 0x1a
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     48e:	8b 8d       	ldd	r24, Y+27	; 0x1b
     490:	9c 8d       	ldd	r25, Y+28	; 0x1c
     492:	dc d5       	rcall	.+3000   	; 0x104c <__fixunssfsi>
     494:	dc 01       	movw	r26, r24
     496:	cb 01       	movw	r24, r22
     498:	9e 8f       	std	Y+30, r25	; 0x1e
     49a:	8d 8f       	std	Y+29, r24	; 0x1d
     49c:	8d 8d       	ldd	r24, Y+29	; 0x1d
     49e:	9e 8d       	ldd	r25, Y+30	; 0x1e
     4a0:	9a a3       	std	Y+34, r25	; 0x22
     4a2:	89 a3       	std	Y+33, r24	; 0x21
     4a4:	89 a1       	ldd	r24, Y+33	; 0x21
     4a6:	9a a1       	ldd	r25, Y+34	; 0x22
     4a8:	01 97       	sbiw	r24, 0x01	; 1
     4aa:	f1 f7       	brne	.-4      	; 0x4a8 <__LOCK_REGION_LENGTH__+0xa8>
     4ac:	9a a3       	std	Y+34, r25	; 0x22
     4ae:	89 a3       	std	Y+33, r24	; 0x21
     4b0:	0f de       	rcall	.-994    	; 0xd0 <Led1_Off>
            _delay_ms(500);
            Led1_Off();
     4b2:	19 c3       	rjmp	.+1586   	; 0xae6 <__stack+0x1e7>
     4b4:	ed de       	rcall	.-550    	; 0x290 <Taster2_get>
            default:
                mode = 0;
                break;
        }
    }
}
     4b6:	89 2b       	or	r24, r25
            mode = 1;
            PORTB = 0x00;
            Led1_On();
            _delay_ms(500);
            Led1_Off();
        } else if (Taster2_get()) {
     4b8:	09 f4       	brne	.+2      	; 0x4bc <__LOCK_REGION_LENGTH__+0xbc>
     4ba:	79 c0       	rjmp	.+242    	; 0x5ae <__LOCK_REGION_LENGTH__+0x1ae>
     4bc:	82 e0       	ldi	r24, 0x02	; 2
     4be:	90 e0       	ldi	r25, 0x00	; 0
            mode = 2;
     4c0:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <mode.1739+0x1>
     4c4:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <mode.1739>
     4c8:	85 e2       	ldi	r24, 0x25	; 37
     4ca:	90 e0       	ldi	r25, 0x00	; 0
            PORTB = 0x00;
     4cc:	fc 01       	movw	r30, r24
     4ce:	10 82       	st	Z, r1
     4d0:	10 de       	rcall	.-992    	; 0xf2 <Led2_On>
     4d2:	80 e0       	ldi	r24, 0x00	; 0
            Led2_On();
     4d4:	90 e0       	ldi	r25, 0x00	; 0
     4d6:	aa ef       	ldi	r26, 0xFA	; 250
     4d8:	b3 e4       	ldi	r27, 0x43	; 67
     4da:	89 83       	std	Y+1, r24	; 0x01
     4dc:	9a 83       	std	Y+2, r25	; 0x02
     4de:	ab 83       	std	Y+3, r26	; 0x03
     4e0:	bc 83       	std	Y+4, r27	; 0x04
     4e2:	20 e0       	ldi	r18, 0x00	; 0
     4e4:	30 e0       	ldi	r19, 0x00	; 0

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     4e6:	4a e7       	ldi	r20, 0x7A	; 122
     4e8:	53 e4       	ldi	r21, 0x43	; 67
     4ea:	69 81       	ldd	r22, Y+1	; 0x01
     4ec:	7a 81       	ldd	r23, Y+2	; 0x02
     4ee:	8b 81       	ldd	r24, Y+3	; 0x03
     4f0:	9c 81       	ldd	r25, Y+4	; 0x04
     4f2:	29 d6       	rcall	.+3154   	; 0x1146 <__mulsf3>
     4f4:	dc 01       	movw	r26, r24
     4f6:	cb 01       	movw	r24, r22
     4f8:	8b a3       	std	Y+35, r24	; 0x23
     4fa:	9c a3       	std	Y+36, r25	; 0x24
     4fc:	ad a3       	std	Y+37, r26	; 0x25
     4fe:	be a3       	std	Y+38, r27	; 0x26
     500:	20 e0       	ldi	r18, 0x00	; 0
     502:	30 e0       	ldi	r19, 0x00	; 0
	if (__tmp < 1.0)
     504:	40 e8       	ldi	r20, 0x80	; 128
     506:	5f e3       	ldi	r21, 0x3F	; 63
     508:	6b a1       	ldd	r22, Y+35	; 0x23
     50a:	7c a1       	ldd	r23, Y+36	; 0x24
     50c:	8d a1       	ldd	r24, Y+37	; 0x25
     50e:	9e a1       	ldd	r25, Y+38	; 0x26
     510:	99 d5       	rcall	.+2866   	; 0x1044 <__cmpsf2>
     512:	88 23       	and	r24, r24
     514:	2c f4       	brge	.+10     	; 0x520 <__LOCK_REGION_LENGTH__+0x120>
     516:	81 e0       	ldi	r24, 0x01	; 1
     518:	90 e0       	ldi	r25, 0x00	; 0
		__ticks = 1;
     51a:	98 a7       	std	Y+40, r25	; 0x28
     51c:	8f a3       	std	Y+39, r24	; 0x27
     51e:	3b c0       	rjmp	.+118    	; 0x596 <__LOCK_REGION_LENGTH__+0x196>
     520:	20 e0       	ldi	r18, 0x00	; 0
     522:	3f ef       	ldi	r19, 0xFF	; 255
	else if (__tmp > 65535)
     524:	4f e7       	ldi	r20, 0x7F	; 127
     526:	57 e4       	ldi	r21, 0x47	; 71
     528:	6b a1       	ldd	r22, Y+35	; 0x23
     52a:	7c a1       	ldd	r23, Y+36	; 0x24
     52c:	8d a1       	ldd	r24, Y+37	; 0x25
     52e:	9e a1       	ldd	r25, Y+38	; 0x26
     530:	06 d6       	rcall	.+3084   	; 0x113e <__gesf2>
     532:	18 16       	cp	r1, r24
     534:	3c f5       	brge	.+78     	; 0x584 <__LOCK_REGION_LENGTH__+0x184>
     536:	20 e0       	ldi	r18, 0x00	; 0
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     538:	30 e0       	ldi	r19, 0x00	; 0
     53a:	40 e2       	ldi	r20, 0x20	; 32
     53c:	51 e4       	ldi	r21, 0x41	; 65
     53e:	69 81       	ldd	r22, Y+1	; 0x01
     540:	7a 81       	ldd	r23, Y+2	; 0x02
     542:	8b 81       	ldd	r24, Y+3	; 0x03
     544:	9c 81       	ldd	r25, Y+4	; 0x04
     546:	ff d5       	rcall	.+3070   	; 0x1146 <__mulsf3>
     548:	dc 01       	movw	r26, r24
     54a:	cb 01       	movw	r24, r22
     54c:	bc 01       	movw	r22, r24
     54e:	cd 01       	movw	r24, r26
     550:	7d d5       	rcall	.+2810   	; 0x104c <__fixunssfsi>
     552:	dc 01       	movw	r26, r24
     554:	cb 01       	movw	r24, r22
     556:	98 a7       	std	Y+40, r25	; 0x28
     558:	8f a3       	std	Y+39, r24	; 0x27
     55a:	0f c0       	rjmp	.+30     	; 0x57a <__LOCK_REGION_LENGTH__+0x17a>
     55c:	89 e1       	ldi	r24, 0x19	; 25
     55e:	90 e0       	ldi	r25, 0x00	; 0
     560:	9a a7       	std	Y+42, r25	; 0x2a
     562:	89 a7       	std	Y+41, r24	; 0x29
     564:	89 a5       	ldd	r24, Y+41	; 0x29
     566:	9a a5       	ldd	r25, Y+42	; 0x2a
     568:	01 97       	sbiw	r24, 0x01	; 1
     56a:	f1 f7       	brne	.-4      	; 0x568 <__LOCK_REGION_LENGTH__+0x168>
     56c:	9a a7       	std	Y+42, r25	; 0x2a
     56e:	89 a7       	std	Y+41, r24	; 0x29
     570:	8f a1       	ldd	r24, Y+39	; 0x27
     572:	98 a5       	ldd	r25, Y+40	; 0x28
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     574:	01 97       	sbiw	r24, 0x01	; 1
     576:	98 a7       	std	Y+40, r25	; 0x28
     578:	8f a3       	std	Y+39, r24	; 0x27
     57a:	8f a1       	ldd	r24, Y+39	; 0x27
     57c:	98 a5       	ldd	r25, Y+40	; 0x28
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     57e:	89 2b       	or	r24, r25
     580:	69 f7       	brne	.-38     	; 0x55c <__LOCK_REGION_LENGTH__+0x15c>
     582:	13 c0       	rjmp	.+38     	; 0x5aa <__LOCK_REGION_LENGTH__+0x1aa>
     584:	6b a1       	ldd	r22, Y+35	; 0x23
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     586:	7c a1       	ldd	r23, Y+36	; 0x24
     588:	8d a1       	ldd	r24, Y+37	; 0x25
     58a:	9e a1       	ldd	r25, Y+38	; 0x26
     58c:	5f d5       	rcall	.+2750   	; 0x104c <__fixunssfsi>
     58e:	dc 01       	movw	r26, r24
     590:	cb 01       	movw	r24, r22
     592:	98 a7       	std	Y+40, r25	; 0x28
     594:	8f a3       	std	Y+39, r24	; 0x27
     596:	8f a1       	ldd	r24, Y+39	; 0x27
     598:	98 a5       	ldd	r25, Y+40	; 0x28
     59a:	9c a7       	std	Y+44, r25	; 0x2c
     59c:	8b a7       	std	Y+43, r24	; 0x2b
     59e:	8b a5       	ldd	r24, Y+43	; 0x2b
     5a0:	9c a5       	ldd	r25, Y+44	; 0x2c
     5a2:	01 97       	sbiw	r24, 0x01	; 1
     5a4:	f1 f7       	brne	.-4      	; 0x5a2 <__LOCK_REGION_LENGTH__+0x1a2>
     5a6:	9c a7       	std	Y+44, r25	; 0x2c
     5a8:	8b a7       	std	Y+43, r24	; 0x2b
            _delay_ms(500);
            Led2_Off();
     5aa:	b4 dd       	rcall	.-1176   	; 0x114 <Led2_Off>
     5ac:	9c c2       	rjmp	.+1336   	; 0xae6 <__stack+0x1e7>
            default:
                mode = 0;
                break;
        }
    }
}
     5ae:	88 de       	rcall	.-752    	; 0x2c0 <Taster3_get>
            mode = 2;
            PORTB = 0x00;
            Led2_On();
            _delay_ms(500);
            Led2_Off();
        } else if (Taster3_get()) {
     5b0:	89 2b       	or	r24, r25
     5b2:	09 f4       	brne	.+2      	; 0x5b6 <__LOCK_REGION_LENGTH__+0x1b6>
     5b4:	79 c0       	rjmp	.+242    	; 0x6a8 <__LOCK_REGION_LENGTH__+0x2a8>
     5b6:	83 e0       	ldi	r24, 0x03	; 3
     5b8:	90 e0       	ldi	r25, 0x00	; 0
            mode = 3;
     5ba:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <mode.1739+0x1>
     5be:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <mode.1739>
     5c2:	85 e2       	ldi	r24, 0x25	; 37
            PORTB = 0x00;
     5c4:	90 e0       	ldi	r25, 0x00	; 0
     5c6:	fc 01       	movw	r30, r24
     5c8:	10 82       	st	Z, r1
     5ca:	b5 dd       	rcall	.-1174   	; 0x136 <Led3_On>
            Led3_On();
     5cc:	80 e0       	ldi	r24, 0x00	; 0
     5ce:	90 e0       	ldi	r25, 0x00	; 0
     5d0:	aa ef       	ldi	r26, 0xFA	; 250
     5d2:	b3 e4       	ldi	r27, 0x43	; 67
     5d4:	8d 83       	std	Y+5, r24	; 0x05
     5d6:	9e 83       	std	Y+6, r25	; 0x06
     5d8:	af 83       	std	Y+7, r26	; 0x07
     5da:	b8 87       	std	Y+8, r27	; 0x08
     5dc:	20 e0       	ldi	r18, 0x00	; 0

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     5de:	30 e0       	ldi	r19, 0x00	; 0
     5e0:	4a e7       	ldi	r20, 0x7A	; 122
     5e2:	53 e4       	ldi	r21, 0x43	; 67
     5e4:	6d 81       	ldd	r22, Y+5	; 0x05
     5e6:	7e 81       	ldd	r23, Y+6	; 0x06
     5e8:	8f 81       	ldd	r24, Y+7	; 0x07
     5ea:	98 85       	ldd	r25, Y+8	; 0x08
     5ec:	ac d5       	rcall	.+2904   	; 0x1146 <__mulsf3>
     5ee:	dc 01       	movw	r26, r24
     5f0:	cb 01       	movw	r24, r22
     5f2:	8d a7       	std	Y+45, r24	; 0x2d
     5f4:	9e a7       	std	Y+46, r25	; 0x2e
     5f6:	af a7       	std	Y+47, r26	; 0x2f
     5f8:	b8 ab       	std	Y+48, r27	; 0x30
     5fa:	20 e0       	ldi	r18, 0x00	; 0
	if (__tmp < 1.0)
     5fc:	30 e0       	ldi	r19, 0x00	; 0
     5fe:	40 e8       	ldi	r20, 0x80	; 128
     600:	5f e3       	ldi	r21, 0x3F	; 63
     602:	6d a5       	ldd	r22, Y+45	; 0x2d
     604:	7e a5       	ldd	r23, Y+46	; 0x2e
     606:	8f a5       	ldd	r24, Y+47	; 0x2f
     608:	98 a9       	ldd	r25, Y+48	; 0x30
     60a:	1c d5       	rcall	.+2616   	; 0x1044 <__cmpsf2>
     60c:	88 23       	and	r24, r24
     60e:	2c f4       	brge	.+10     	; 0x61a <__LOCK_REGION_LENGTH__+0x21a>
     610:	81 e0       	ldi	r24, 0x01	; 1
		__ticks = 1;
     612:	90 e0       	ldi	r25, 0x00	; 0
     614:	9a ab       	std	Y+50, r25	; 0x32
     616:	89 ab       	std	Y+49, r24	; 0x31
     618:	3b c0       	rjmp	.+118    	; 0x690 <__LOCK_REGION_LENGTH__+0x290>
	else if (__tmp > 65535)
     61a:	20 e0       	ldi	r18, 0x00	; 0
     61c:	3f ef       	ldi	r19, 0xFF	; 255
     61e:	4f e7       	ldi	r20, 0x7F	; 127
     620:	57 e4       	ldi	r21, 0x47	; 71
     622:	6d a5       	ldd	r22, Y+45	; 0x2d
     624:	7e a5       	ldd	r23, Y+46	; 0x2e
     626:	8f a5       	ldd	r24, Y+47	; 0x2f
     628:	98 a9       	ldd	r25, Y+48	; 0x30
     62a:	89 d5       	rcall	.+2834   	; 0x113e <__gesf2>
     62c:	18 16       	cp	r1, r24
     62e:	3c f5       	brge	.+78     	; 0x67e <__LOCK_REGION_LENGTH__+0x27e>
     630:	20 e0       	ldi	r18, 0x00	; 0
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     632:	30 e0       	ldi	r19, 0x00	; 0
     634:	40 e2       	ldi	r20, 0x20	; 32
     636:	51 e4       	ldi	r21, 0x41	; 65
     638:	6d 81       	ldd	r22, Y+5	; 0x05
     63a:	7e 81       	ldd	r23, Y+6	; 0x06
     63c:	8f 81       	ldd	r24, Y+7	; 0x07
     63e:	98 85       	ldd	r25, Y+8	; 0x08
     640:	82 d5       	rcall	.+2820   	; 0x1146 <__mulsf3>
     642:	dc 01       	movw	r26, r24
     644:	cb 01       	movw	r24, r22
     646:	bc 01       	movw	r22, r24
     648:	cd 01       	movw	r24, r26
     64a:	00 d5       	rcall	.+2560   	; 0x104c <__fixunssfsi>
     64c:	dc 01       	movw	r26, r24
     64e:	cb 01       	movw	r24, r22
     650:	9a ab       	std	Y+50, r25	; 0x32
     652:	89 ab       	std	Y+49, r24	; 0x31
     654:	0f c0       	rjmp	.+30     	; 0x674 <__LOCK_REGION_LENGTH__+0x274>
     656:	89 e1       	ldi	r24, 0x19	; 25
     658:	90 e0       	ldi	r25, 0x00	; 0
     65a:	9c ab       	std	Y+52, r25	; 0x34
     65c:	8b ab       	std	Y+51, r24	; 0x33
     65e:	8b a9       	ldd	r24, Y+51	; 0x33
     660:	9c a9       	ldd	r25, Y+52	; 0x34
     662:	01 97       	sbiw	r24, 0x01	; 1
     664:	f1 f7       	brne	.-4      	; 0x662 <__LOCK_REGION_LENGTH__+0x262>
     666:	9c ab       	std	Y+52, r25	; 0x34
     668:	8b ab       	std	Y+51, r24	; 0x33
     66a:	89 a9       	ldd	r24, Y+49	; 0x31
     66c:	9a a9       	ldd	r25, Y+50	; 0x32
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     66e:	01 97       	sbiw	r24, 0x01	; 1
     670:	9a ab       	std	Y+50, r25	; 0x32
     672:	89 ab       	std	Y+49, r24	; 0x31
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     674:	89 a9       	ldd	r24, Y+49	; 0x31
     676:	9a a9       	ldd	r25, Y+50	; 0x32
     678:	89 2b       	or	r24, r25
     67a:	69 f7       	brne	.-38     	; 0x656 <__LOCK_REGION_LENGTH__+0x256>
     67c:	13 c0       	rjmp	.+38     	; 0x6a4 <__LOCK_REGION_LENGTH__+0x2a4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     67e:	6d a5       	ldd	r22, Y+45	; 0x2d
     680:	7e a5       	ldd	r23, Y+46	; 0x2e
     682:	8f a5       	ldd	r24, Y+47	; 0x2f
     684:	98 a9       	ldd	r25, Y+48	; 0x30
     686:	e2 d4       	rcall	.+2500   	; 0x104c <__fixunssfsi>
     688:	dc 01       	movw	r26, r24
     68a:	cb 01       	movw	r24, r22
     68c:	9a ab       	std	Y+50, r25	; 0x32
     68e:	89 ab       	std	Y+49, r24	; 0x31
     690:	89 a9       	ldd	r24, Y+49	; 0x31
     692:	9a a9       	ldd	r25, Y+50	; 0x32
     694:	9e ab       	std	Y+54, r25	; 0x36
     696:	8d ab       	std	Y+53, r24	; 0x35
     698:	8d a9       	ldd	r24, Y+53	; 0x35
     69a:	9e a9       	ldd	r25, Y+54	; 0x36
     69c:	01 97       	sbiw	r24, 0x01	; 1
     69e:	f1 f7       	brne	.-4      	; 0x69c <__LOCK_REGION_LENGTH__+0x29c>
     6a0:	9e ab       	std	Y+54, r25	; 0x36
     6a2:	8d ab       	std	Y+53, r24	; 0x35
            _delay_ms(500);
            Led3_Off();
     6a4:	59 dd       	rcall	.-1358   	; 0x158 <Led3_Off>
     6a6:	1f c2       	rjmp	.+1086   	; 0xae6 <__stack+0x1e7>
            default:
                mode = 0;
                break;
        }
    }
}
     6a8:	23 de       	rcall	.-954    	; 0x2f0 <Taster4_get>
            mode = 3;
            PORTB = 0x00;
            Led3_On();
            _delay_ms(500);
            Led3_Off();
        } else if (Taster4_get()) {
     6aa:	89 2b       	or	r24, r25
     6ac:	09 f4       	brne	.+2      	; 0x6b0 <__LOCK_REGION_LENGTH__+0x2b0>
     6ae:	1b c2       	rjmp	.+1078   	; 0xae6 <__stack+0x1e7>
     6b0:	84 e0       	ldi	r24, 0x04	; 4
            mode = 4;
     6b2:	90 e0       	ldi	r25, 0x00	; 0
     6b4:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <mode.1739+0x1>
     6b8:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <mode.1739>
     6bc:	85 e2       	ldi	r24, 0x25	; 37
            PORTB = 0x00;
     6be:	90 e0       	ldi	r25, 0x00	; 0
     6c0:	fc 01       	movw	r30, r24
     6c2:	10 82       	st	Z, r1
     6c4:	5a dd       	rcall	.-1356   	; 0x17a <Led4_On>
            Led4_On();
     6c6:	80 e0       	ldi	r24, 0x00	; 0
     6c8:	90 e0       	ldi	r25, 0x00	; 0
     6ca:	aa ef       	ldi	r26, 0xFA	; 250
     6cc:	b3 e4       	ldi	r27, 0x43	; 67
     6ce:	89 87       	std	Y+9, r24	; 0x09
     6d0:	9a 87       	std	Y+10, r25	; 0x0a
     6d2:	ab 87       	std	Y+11, r26	; 0x0b
     6d4:	bc 87       	std	Y+12, r27	; 0x0c
     6d6:	20 e0       	ldi	r18, 0x00	; 0

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     6d8:	30 e0       	ldi	r19, 0x00	; 0
     6da:	4a e7       	ldi	r20, 0x7A	; 122
     6dc:	53 e4       	ldi	r21, 0x43	; 67
     6de:	69 85       	ldd	r22, Y+9	; 0x09
     6e0:	7a 85       	ldd	r23, Y+10	; 0x0a
     6e2:	8b 85       	ldd	r24, Y+11	; 0x0b
     6e4:	9c 85       	ldd	r25, Y+12	; 0x0c
     6e6:	2f d5       	rcall	.+2654   	; 0x1146 <__mulsf3>
     6e8:	dc 01       	movw	r26, r24
     6ea:	cb 01       	movw	r24, r22
     6ec:	8f ab       	std	Y+55, r24	; 0x37
     6ee:	98 af       	std	Y+56, r25	; 0x38
     6f0:	a9 af       	std	Y+57, r26	; 0x39
     6f2:	ba af       	std	Y+58, r27	; 0x3a
     6f4:	20 e0       	ldi	r18, 0x00	; 0
	if (__tmp < 1.0)
     6f6:	30 e0       	ldi	r19, 0x00	; 0
     6f8:	40 e8       	ldi	r20, 0x80	; 128
     6fa:	5f e3       	ldi	r21, 0x3F	; 63
     6fc:	6f a9       	ldd	r22, Y+55	; 0x37
     6fe:	78 ad       	ldd	r23, Y+56	; 0x38
     700:	89 ad       	ldd	r24, Y+57	; 0x39
     702:	9a ad       	ldd	r25, Y+58	; 0x3a
     704:	9f d4       	rcall	.+2366   	; 0x1044 <__cmpsf2>
     706:	88 23       	and	r24, r24
     708:	2c f4       	brge	.+10     	; 0x714 <__LOCK_REGION_LENGTH__+0x314>
		__ticks = 1;
     70a:	81 e0       	ldi	r24, 0x01	; 1
     70c:	90 e0       	ldi	r25, 0x00	; 0
     70e:	9c af       	std	Y+60, r25	; 0x3c
     710:	8b af       	std	Y+59, r24	; 0x3b
     712:	3b c0       	rjmp	.+118    	; 0x78a <__LOCK_REGION_LENGTH__+0x38a>
	else if (__tmp > 65535)
     714:	20 e0       	ldi	r18, 0x00	; 0
     716:	3f ef       	ldi	r19, 0xFF	; 255
     718:	4f e7       	ldi	r20, 0x7F	; 127
     71a:	57 e4       	ldi	r21, 0x47	; 71
     71c:	6f a9       	ldd	r22, Y+55	; 0x37
     71e:	78 ad       	ldd	r23, Y+56	; 0x38
     720:	89 ad       	ldd	r24, Y+57	; 0x39
     722:	9a ad       	ldd	r25, Y+58	; 0x3a
     724:	0c d5       	rcall	.+2584   	; 0x113e <__gesf2>
     726:	18 16       	cp	r1, r24
     728:	3c f5       	brge	.+78     	; 0x778 <__LOCK_REGION_LENGTH__+0x378>
     72a:	20 e0       	ldi	r18, 0x00	; 0
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     72c:	30 e0       	ldi	r19, 0x00	; 0
     72e:	40 e2       	ldi	r20, 0x20	; 32
     730:	51 e4       	ldi	r21, 0x41	; 65
     732:	69 85       	ldd	r22, Y+9	; 0x09
     734:	7a 85       	ldd	r23, Y+10	; 0x0a
     736:	8b 85       	ldd	r24, Y+11	; 0x0b
     738:	9c 85       	ldd	r25, Y+12	; 0x0c
     73a:	05 d5       	rcall	.+2570   	; 0x1146 <__mulsf3>
     73c:	dc 01       	movw	r26, r24
     73e:	cb 01       	movw	r24, r22
     740:	bc 01       	movw	r22, r24
     742:	cd 01       	movw	r24, r26
     744:	83 d4       	rcall	.+2310   	; 0x104c <__fixunssfsi>
     746:	dc 01       	movw	r26, r24
     748:	cb 01       	movw	r24, r22
     74a:	9c af       	std	Y+60, r25	; 0x3c
     74c:	8b af       	std	Y+59, r24	; 0x3b
     74e:	0f c0       	rjmp	.+30     	; 0x76e <__LOCK_REGION_LENGTH__+0x36e>
     750:	89 e1       	ldi	r24, 0x19	; 25
     752:	90 e0       	ldi	r25, 0x00	; 0
     754:	9e af       	std	Y+62, r25	; 0x3e
     756:	8d af       	std	Y+61, r24	; 0x3d
     758:	8d ad       	ldd	r24, Y+61	; 0x3d
     75a:	9e ad       	ldd	r25, Y+62	; 0x3e
     75c:	01 97       	sbiw	r24, 0x01	; 1
     75e:	f1 f7       	brne	.-4      	; 0x75c <__LOCK_REGION_LENGTH__+0x35c>
     760:	9e af       	std	Y+62, r25	; 0x3e
     762:	8d af       	std	Y+61, r24	; 0x3d
     764:	8b ad       	ldd	r24, Y+59	; 0x3b
     766:	9c ad       	ldd	r25, Y+60	; 0x3c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     768:	01 97       	sbiw	r24, 0x01	; 1
     76a:	9c af       	std	Y+60, r25	; 0x3c
     76c:	8b af       	std	Y+59, r24	; 0x3b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     76e:	8b ad       	ldd	r24, Y+59	; 0x3b
     770:	9c ad       	ldd	r25, Y+60	; 0x3c
     772:	89 2b       	or	r24, r25
     774:	69 f7       	brne	.-38     	; 0x750 <__LOCK_REGION_LENGTH__+0x350>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     776:	1d c0       	rjmp	.+58     	; 0x7b2 <__LOCK_REGION_LENGTH__+0x3b2>
     778:	6f a9       	ldd	r22, Y+55	; 0x37
     77a:	78 ad       	ldd	r23, Y+56	; 0x38
     77c:	89 ad       	ldd	r24, Y+57	; 0x39
     77e:	9a ad       	ldd	r25, Y+58	; 0x3a
     780:	65 d4       	rcall	.+2250   	; 0x104c <__fixunssfsi>
     782:	dc 01       	movw	r26, r24
     784:	cb 01       	movw	r24, r22
     786:	9c af       	std	Y+60, r25	; 0x3c
     788:	8b af       	std	Y+59, r24	; 0x3b
     78a:	2b ad       	ldd	r18, Y+59	; 0x3b
     78c:	3c ad       	ldd	r19, Y+60	; 0x3c
     78e:	ce 01       	movw	r24, r28
     790:	cf 96       	adiw	r24, 0x3f	; 63
     792:	fc 01       	movw	r30, r24
     794:	31 83       	std	Z+1, r19	; 0x01
     796:	20 83       	st	Z, r18
     798:	ce 01       	movw	r24, r28
     79a:	cf 96       	adiw	r24, 0x3f	; 63
     79c:	fc 01       	movw	r30, r24
     79e:	80 81       	ld	r24, Z
     7a0:	91 81       	ldd	r25, Z+1	; 0x01
     7a2:	01 97       	sbiw	r24, 0x01	; 1
     7a4:	f1 f7       	brne	.-4      	; 0x7a2 <__LOCK_REGION_LENGTH__+0x3a2>
     7a6:	9e 01       	movw	r18, r28
     7a8:	21 5c       	subi	r18, 0xC1	; 193
     7aa:	3f 4f       	sbci	r19, 0xFF	; 255
     7ac:	f9 01       	movw	r30, r18
     7ae:	91 83       	std	Z+1, r25	; 0x01
            _delay_ms(500);
            Led4_Off();
     7b0:	80 83       	st	Z, r24
     7b2:	f4 dc       	rcall	.-1560   	; 0x19c <Led4_Off>
            default:
                mode = 0;
                break;
        }
    }
}
     7b4:	98 c1       	rjmp	.+816    	; 0xae6 <__stack+0x1e7>
        }
        
    } else {    // run
        
        // reset if button 1 and button 2 are pressed
        if (Taster1_get() && Taster2_get()) {
     7b6:	51 dd       	rcall	.-1374   	; 0x25a <Taster1_get>
     7b8:	89 2b       	or	r24, r25
     7ba:	09 f4       	brne	.+2      	; 0x7be <__LOCK_REGION_LENGTH__+0x3be>
     7bc:	75 c1       	rjmp	.+746    	; 0xaa8 <__stack+0x1a9>
     7be:	68 dd       	rcall	.-1328   	; 0x290 <Taster2_get>
     7c0:	89 2b       	or	r24, r25
     7c2:	09 f4       	brne	.+2      	; 0x7c6 <__LOCK_REGION_LENGTH__+0x3c6>
     7c4:	71 c1       	rjmp	.+738    	; 0xaa8 <__stack+0x1a9>
     7c6:	10 92 03 01 	sts	0x0103, r1	; 0x800103 <mode.1739+0x1>
            mode = 0;
     7ca:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <mode.1739>
     7ce:	80 e0       	ldi	r24, 0x00	; 0
     7d0:	90 e0       	ldi	r25, 0x00	; 0
     7d2:	aa e7       	ldi	r26, 0x7A	; 122
     7d4:	b4 e4       	ldi	r27, 0x44	; 68
     7d6:	89 8b       	std	Y+17, r24	; 0x11
     7d8:	9a 8b       	std	Y+18, r25	; 0x12
     7da:	ab 8b       	std	Y+19, r26	; 0x13
     7dc:	bc 8b       	std	Y+20, r27	; 0x14
     7de:	8e 01       	movw	r16, r28

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     7e0:	05 5b       	subi	r16, 0xB5	; 181
     7e2:	1f 4f       	sbci	r17, 0xFF	; 255
     7e4:	20 e0       	ldi	r18, 0x00	; 0
     7e6:	30 e0       	ldi	r19, 0x00	; 0
     7e8:	4a e7       	ldi	r20, 0x7A	; 122
     7ea:	53 e4       	ldi	r21, 0x43	; 67
     7ec:	69 89       	ldd	r22, Y+17	; 0x11
     7ee:	7a 89       	ldd	r23, Y+18	; 0x12
     7f0:	8b 89       	ldd	r24, Y+19	; 0x13
     7f2:	9c 89       	ldd	r25, Y+20	; 0x14
     7f4:	a8 d4       	rcall	.+2384   	; 0x1146 <__mulsf3>
     7f6:	dc 01       	movw	r26, r24
     7f8:	cb 01       	movw	r24, r22
     7fa:	f8 01       	movw	r30, r16
     7fc:	80 83       	st	Z, r24
     7fe:	91 83       	std	Z+1, r25	; 0x01
     800:	a2 83       	std	Z+2, r26	; 0x02
     802:	b3 83       	std	Z+3, r27	; 0x03
     804:	ce 01       	movw	r24, r28
	if (__tmp < 1.0)
     806:	85 5b       	subi	r24, 0xB5	; 181
     808:	9f 4f       	sbci	r25, 0xFF	; 255
     80a:	20 e0       	ldi	r18, 0x00	; 0
     80c:	30 e0       	ldi	r19, 0x00	; 0
     80e:	40 e8       	ldi	r20, 0x80	; 128
     810:	5f e3       	ldi	r21, 0x3F	; 63
     812:	fc 01       	movw	r30, r24
     814:	60 81       	ld	r22, Z
     816:	71 81       	ldd	r23, Z+1	; 0x01
     818:	82 81       	ldd	r24, Z+2	; 0x02
     81a:	93 81       	ldd	r25, Z+3	; 0x03
     81c:	13 d4       	rcall	.+2086   	; 0x1044 <__cmpsf2>
     81e:	88 23       	and	r24, r24
     820:	4c f4       	brge	.+18     	; 0x834 <__LOCK_REGION_LENGTH__+0x434>
		__ticks = 1;
     822:	ce 01       	movw	r24, r28
     824:	81 5b       	subi	r24, 0xB1	; 177
     826:	9f 4f       	sbci	r25, 0xFF	; 255
     828:	21 e0       	ldi	r18, 0x01	; 1
     82a:	30 e0       	ldi	r19, 0x00	; 0
     82c:	fc 01       	movw	r30, r24
     82e:	31 83       	std	Z+1, r19	; 0x01
     830:	20 83       	st	Z, r18
     832:	65 c0       	rjmp	.+202    	; 0x8fe <__LOCK_REGION_LENGTH__+0x4fe>
	else if (__tmp > 65535)
     834:	ce 01       	movw	r24, r28
     836:	85 5b       	subi	r24, 0xB5	; 181
     838:	9f 4f       	sbci	r25, 0xFF	; 255
     83a:	20 e0       	ldi	r18, 0x00	; 0
     83c:	3f ef       	ldi	r19, 0xFF	; 255
     83e:	4f e7       	ldi	r20, 0x7F	; 127
     840:	57 e4       	ldi	r21, 0x47	; 71
     842:	fc 01       	movw	r30, r24
     844:	60 81       	ld	r22, Z
     846:	71 81       	ldd	r23, Z+1	; 0x01
     848:	82 81       	ldd	r24, Z+2	; 0x02
     84a:	93 81       	ldd	r25, Z+3	; 0x03
     84c:	78 d4       	rcall	.+2288   	; 0x113e <__gesf2>
     84e:	18 16       	cp	r1, r24
     850:	0c f0       	brlt	.+2      	; 0x854 <__LOCK_REGION_LENGTH__+0x454>
     852:	44 c0       	rjmp	.+136    	; 0x8dc <__LOCK_REGION_LENGTH__+0x4dc>
     854:	20 e0       	ldi	r18, 0x00	; 0
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     856:	30 e0       	ldi	r19, 0x00	; 0
     858:	40 e2       	ldi	r20, 0x20	; 32
     85a:	51 e4       	ldi	r21, 0x41	; 65
     85c:	69 89       	ldd	r22, Y+17	; 0x11
     85e:	7a 89       	ldd	r23, Y+18	; 0x12
     860:	8b 89       	ldd	r24, Y+19	; 0x13
     862:	9c 89       	ldd	r25, Y+20	; 0x14
     864:	70 d4       	rcall	.+2272   	; 0x1146 <__mulsf3>
     866:	dc 01       	movw	r26, r24
     868:	cb 01       	movw	r24, r22
     86a:	8e 01       	movw	r16, r28
     86c:	01 5b       	subi	r16, 0xB1	; 177
     86e:	1f 4f       	sbci	r17, 0xFF	; 255
     870:	bc 01       	movw	r22, r24
     872:	cd 01       	movw	r24, r26
     874:	eb d3       	rcall	.+2006   	; 0x104c <__fixunssfsi>
     876:	dc 01       	movw	r26, r24
     878:	cb 01       	movw	r24, r22
     87a:	f8 01       	movw	r30, r16
     87c:	91 83       	std	Z+1, r25	; 0x01
     87e:	80 83       	st	Z, r24
     880:	24 c0       	rjmp	.+72     	; 0x8ca <__LOCK_REGION_LENGTH__+0x4ca>
     882:	ce 01       	movw	r24, r28
     884:	8f 5a       	subi	r24, 0xAF	; 175
     886:	9f 4f       	sbci	r25, 0xFF	; 255
     888:	29 e1       	ldi	r18, 0x19	; 25
     88a:	30 e0       	ldi	r19, 0x00	; 0
     88c:	fc 01       	movw	r30, r24
     88e:	31 83       	std	Z+1, r19	; 0x01
     890:	20 83       	st	Z, r18
     892:	ce 01       	movw	r24, r28
     894:	8f 5a       	subi	r24, 0xAF	; 175
     896:	9f 4f       	sbci	r25, 0xFF	; 255
     898:	fc 01       	movw	r30, r24
     89a:	80 81       	ld	r24, Z
     89c:	91 81       	ldd	r25, Z+1	; 0x01
     89e:	01 97       	sbiw	r24, 0x01	; 1
     8a0:	f1 f7       	brne	.-4      	; 0x89e <__LOCK_REGION_LENGTH__+0x49e>
     8a2:	9e 01       	movw	r18, r28
     8a4:	2f 5a       	subi	r18, 0xAF	; 175
     8a6:	3f 4f       	sbci	r19, 0xFF	; 255
     8a8:	f9 01       	movw	r30, r18
     8aa:	91 83       	std	Z+1, r25	; 0x01
     8ac:	80 83       	st	Z, r24
     8ae:	ce 01       	movw	r24, r28
     8b0:	81 5b       	subi	r24, 0xB1	; 177
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     8b2:	9f 4f       	sbci	r25, 0xFF	; 255
     8b4:	9e 01       	movw	r18, r28
     8b6:	21 5b       	subi	r18, 0xB1	; 177
     8b8:	3f 4f       	sbci	r19, 0xFF	; 255
     8ba:	f9 01       	movw	r30, r18
     8bc:	20 81       	ld	r18, Z
     8be:	31 81       	ldd	r19, Z+1	; 0x01
     8c0:	21 50       	subi	r18, 0x01	; 1
     8c2:	31 09       	sbc	r19, r1
     8c4:	fc 01       	movw	r30, r24
     8c6:	31 83       	std	Z+1, r19	; 0x01
     8c8:	20 83       	st	Z, r18
     8ca:	ce 01       	movw	r24, r28
     8cc:	81 5b       	subi	r24, 0xB1	; 177
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     8ce:	9f 4f       	sbci	r25, 0xFF	; 255
     8d0:	fc 01       	movw	r30, r24
     8d2:	80 81       	ld	r24, Z
     8d4:	91 81       	ldd	r25, Z+1	; 0x01
     8d6:	89 2b       	or	r24, r25
     8d8:	a1 f6       	brne	.-88     	; 0x882 <__LOCK_REGION_LENGTH__+0x482>
     8da:	2b c0       	rjmp	.+86     	; 0x932 <__stack+0x33>
     8dc:	8e 01       	movw	r16, r28
     8de:	01 5b       	subi	r16, 0xB1	; 177
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     8e0:	1f 4f       	sbci	r17, 0xFF	; 255
     8e2:	ce 01       	movw	r24, r28
     8e4:	85 5b       	subi	r24, 0xB5	; 181
     8e6:	9f 4f       	sbci	r25, 0xFF	; 255
     8e8:	fc 01       	movw	r30, r24
     8ea:	60 81       	ld	r22, Z
     8ec:	71 81       	ldd	r23, Z+1	; 0x01
     8ee:	82 81       	ldd	r24, Z+2	; 0x02
     8f0:	93 81       	ldd	r25, Z+3	; 0x03
     8f2:	ac d3       	rcall	.+1880   	; 0x104c <__fixunssfsi>
     8f4:	dc 01       	movw	r26, r24
     8f6:	cb 01       	movw	r24, r22
     8f8:	f8 01       	movw	r30, r16
     8fa:	91 83       	std	Z+1, r25	; 0x01
     8fc:	80 83       	st	Z, r24
     8fe:	ce 01       	movw	r24, r28
     900:	8d 5a       	subi	r24, 0xAD	; 173
     902:	9f 4f       	sbci	r25, 0xFF	; 255
     904:	9e 01       	movw	r18, r28
     906:	21 5b       	subi	r18, 0xB1	; 177
     908:	3f 4f       	sbci	r19, 0xFF	; 255
     90a:	f9 01       	movw	r30, r18
     90c:	20 81       	ld	r18, Z
     90e:	31 81       	ldd	r19, Z+1	; 0x01
     910:	fc 01       	movw	r30, r24
     912:	31 83       	std	Z+1, r19	; 0x01
     914:	20 83       	st	Z, r18
     916:	ce 01       	movw	r24, r28
     918:	8d 5a       	subi	r24, 0xAD	; 173
     91a:	9f 4f       	sbci	r25, 0xFF	; 255
     91c:	fc 01       	movw	r30, r24
     91e:	80 81       	ld	r24, Z
     920:	91 81       	ldd	r25, Z+1	; 0x01
     922:	01 97       	sbiw	r24, 0x01	; 1
     924:	f1 f7       	brne	.-4      	; 0x922 <__stack+0x23>
     926:	9e 01       	movw	r18, r28
     928:	2d 5a       	subi	r18, 0xAD	; 173
     92a:	3f 4f       	sbci	r19, 0xFF	; 255
     92c:	f9 01       	movw	r30, r18
     92e:	91 83       	std	Z+1, r25	; 0x01
     930:	80 83       	st	Z, r24
     932:	85 e2       	ldi	r24, 0x25	; 37
            _delay_ms(1000);
            PORTB = 0xFF;
     934:	90 e0       	ldi	r25, 0x00	; 0
     936:	2f ef       	ldi	r18, 0xFF	; 255
     938:	fc 01       	movw	r30, r24
     93a:	20 83       	st	Z, r18
     93c:	80 e0       	ldi	r24, 0x00	; 0
     93e:	90 e0       	ldi	r25, 0x00	; 0
     940:	aa ef       	ldi	r26, 0xFA	; 250
     942:	b3 e4       	ldi	r27, 0x43	; 67
     944:	8d 87       	std	Y+13, r24	; 0x0d
     946:	9e 87       	std	Y+14, r25	; 0x0e
     948:	af 87       	std	Y+15, r26	; 0x0f
     94a:	b8 8b       	std	Y+16, r27	; 0x10
     94c:	8e 01       	movw	r16, r28

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     94e:	0f 5b       	subi	r16, 0xBF	; 191
     950:	1f 4f       	sbci	r17, 0xFF	; 255
     952:	20 e0       	ldi	r18, 0x00	; 0
     954:	30 e0       	ldi	r19, 0x00	; 0
     956:	4a e7       	ldi	r20, 0x7A	; 122
     958:	53 e4       	ldi	r21, 0x43	; 67
     95a:	6d 85       	ldd	r22, Y+13	; 0x0d
     95c:	7e 85       	ldd	r23, Y+14	; 0x0e
     95e:	8f 85       	ldd	r24, Y+15	; 0x0f
     960:	98 89       	ldd	r25, Y+16	; 0x10
     962:	f1 d3       	rcall	.+2018   	; 0x1146 <__mulsf3>
     964:	dc 01       	movw	r26, r24
     966:	cb 01       	movw	r24, r22
     968:	f8 01       	movw	r30, r16
     96a:	80 83       	st	Z, r24
     96c:	91 83       	std	Z+1, r25	; 0x01
     96e:	a2 83       	std	Z+2, r26	; 0x02
     970:	b3 83       	std	Z+3, r27	; 0x03
     972:	ce 01       	movw	r24, r28
	if (__tmp < 1.0)
     974:	8f 5b       	subi	r24, 0xBF	; 191
     976:	9f 4f       	sbci	r25, 0xFF	; 255
     978:	20 e0       	ldi	r18, 0x00	; 0
     97a:	30 e0       	ldi	r19, 0x00	; 0
     97c:	40 e8       	ldi	r20, 0x80	; 128
     97e:	5f e3       	ldi	r21, 0x3F	; 63
     980:	fc 01       	movw	r30, r24
     982:	60 81       	ld	r22, Z
     984:	71 81       	ldd	r23, Z+1	; 0x01
     986:	82 81       	ldd	r24, Z+2	; 0x02
     988:	93 81       	ldd	r25, Z+3	; 0x03
     98a:	5c d3       	rcall	.+1720   	; 0x1044 <__cmpsf2>
     98c:	88 23       	and	r24, r24
     98e:	4c f4       	brge	.+18     	; 0x9a2 <__stack+0xa3>
     990:	ce 01       	movw	r24, r28
		__ticks = 1;
     992:	8b 5b       	subi	r24, 0xBB	; 187
     994:	9f 4f       	sbci	r25, 0xFF	; 255
     996:	21 e0       	ldi	r18, 0x01	; 1
     998:	30 e0       	ldi	r19, 0x00	; 0
     99a:	fc 01       	movw	r30, r24
     99c:	31 83       	std	Z+1, r19	; 0x01
     99e:	20 83       	st	Z, r18
     9a0:	65 c0       	rjmp	.+202    	; 0xa6c <__stack+0x16d>
     9a2:	ce 01       	movw	r24, r28
	else if (__tmp > 65535)
     9a4:	8f 5b       	subi	r24, 0xBF	; 191
     9a6:	9f 4f       	sbci	r25, 0xFF	; 255
     9a8:	20 e0       	ldi	r18, 0x00	; 0
     9aa:	3f ef       	ldi	r19, 0xFF	; 255
     9ac:	4f e7       	ldi	r20, 0x7F	; 127
     9ae:	57 e4       	ldi	r21, 0x47	; 71
     9b0:	fc 01       	movw	r30, r24
     9b2:	60 81       	ld	r22, Z
     9b4:	71 81       	ldd	r23, Z+1	; 0x01
     9b6:	82 81       	ldd	r24, Z+2	; 0x02
     9b8:	93 81       	ldd	r25, Z+3	; 0x03
     9ba:	c1 d3       	rcall	.+1922   	; 0x113e <__gesf2>
     9bc:	18 16       	cp	r1, r24
     9be:	0c f0       	brlt	.+2      	; 0x9c2 <__stack+0xc3>
     9c0:	44 c0       	rjmp	.+136    	; 0xa4a <__stack+0x14b>
     9c2:	20 e0       	ldi	r18, 0x00	; 0
     9c4:	30 e0       	ldi	r19, 0x00	; 0
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     9c6:	40 e2       	ldi	r20, 0x20	; 32
     9c8:	51 e4       	ldi	r21, 0x41	; 65
     9ca:	6d 85       	ldd	r22, Y+13	; 0x0d
     9cc:	7e 85       	ldd	r23, Y+14	; 0x0e
     9ce:	8f 85       	ldd	r24, Y+15	; 0x0f
     9d0:	98 89       	ldd	r25, Y+16	; 0x10
     9d2:	b9 d3       	rcall	.+1906   	; 0x1146 <__mulsf3>
     9d4:	dc 01       	movw	r26, r24
     9d6:	cb 01       	movw	r24, r22
     9d8:	8e 01       	movw	r16, r28
     9da:	0b 5b       	subi	r16, 0xBB	; 187
     9dc:	1f 4f       	sbci	r17, 0xFF	; 255
     9de:	bc 01       	movw	r22, r24
     9e0:	cd 01       	movw	r24, r26
     9e2:	34 d3       	rcall	.+1640   	; 0x104c <__fixunssfsi>
     9e4:	dc 01       	movw	r26, r24
     9e6:	cb 01       	movw	r24, r22
     9e8:	f8 01       	movw	r30, r16
     9ea:	91 83       	std	Z+1, r25	; 0x01
     9ec:	80 83       	st	Z, r24
     9ee:	24 c0       	rjmp	.+72     	; 0xa38 <__stack+0x139>
     9f0:	ce 01       	movw	r24, r28
     9f2:	89 5b       	subi	r24, 0xB9	; 185
     9f4:	9f 4f       	sbci	r25, 0xFF	; 255
     9f6:	29 e1       	ldi	r18, 0x19	; 25
     9f8:	30 e0       	ldi	r19, 0x00	; 0
     9fa:	fc 01       	movw	r30, r24
     9fc:	31 83       	std	Z+1, r19	; 0x01
     9fe:	20 83       	st	Z, r18
     a00:	ce 01       	movw	r24, r28
     a02:	89 5b       	subi	r24, 0xB9	; 185
     a04:	9f 4f       	sbci	r25, 0xFF	; 255
     a06:	fc 01       	movw	r30, r24
     a08:	80 81       	ld	r24, Z
     a0a:	91 81       	ldd	r25, Z+1	; 0x01
     a0c:	01 97       	sbiw	r24, 0x01	; 1
     a0e:	f1 f7       	brne	.-4      	; 0xa0c <__stack+0x10d>
     a10:	9e 01       	movw	r18, r28
     a12:	29 5b       	subi	r18, 0xB9	; 185
     a14:	3f 4f       	sbci	r19, 0xFF	; 255
     a16:	f9 01       	movw	r30, r18
     a18:	91 83       	std	Z+1, r25	; 0x01
     a1a:	80 83       	st	Z, r24
     a1c:	ce 01       	movw	r24, r28
     a1e:	8b 5b       	subi	r24, 0xBB	; 187
     a20:	9f 4f       	sbci	r25, 0xFF	; 255
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     a22:	9e 01       	movw	r18, r28
     a24:	2b 5b       	subi	r18, 0xBB	; 187
     a26:	3f 4f       	sbci	r19, 0xFF	; 255
     a28:	f9 01       	movw	r30, r18
     a2a:	20 81       	ld	r18, Z
     a2c:	31 81       	ldd	r19, Z+1	; 0x01
     a2e:	21 50       	subi	r18, 0x01	; 1
     a30:	31 09       	sbc	r19, r1
     a32:	fc 01       	movw	r30, r24
     a34:	31 83       	std	Z+1, r19	; 0x01
     a36:	20 83       	st	Z, r18
     a38:	ce 01       	movw	r24, r28
     a3a:	8b 5b       	subi	r24, 0xBB	; 187
     a3c:	9f 4f       	sbci	r25, 0xFF	; 255
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     a3e:	fc 01       	movw	r30, r24
     a40:	80 81       	ld	r24, Z
     a42:	91 81       	ldd	r25, Z+1	; 0x01
     a44:	89 2b       	or	r24, r25
     a46:	a1 f6       	brne	.-88     	; 0x9f0 <__stack+0xf1>
     a48:	2b c0       	rjmp	.+86     	; 0xaa0 <__stack+0x1a1>
     a4a:	8e 01       	movw	r16, r28
     a4c:	0b 5b       	subi	r16, 0xBB	; 187
     a4e:	1f 4f       	sbci	r17, 0xFF	; 255
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     a50:	ce 01       	movw	r24, r28
     a52:	8f 5b       	subi	r24, 0xBF	; 191
     a54:	9f 4f       	sbci	r25, 0xFF	; 255
     a56:	fc 01       	movw	r30, r24
     a58:	60 81       	ld	r22, Z
     a5a:	71 81       	ldd	r23, Z+1	; 0x01
     a5c:	82 81       	ldd	r24, Z+2	; 0x02
     a5e:	93 81       	ldd	r25, Z+3	; 0x03
     a60:	f5 d2       	rcall	.+1514   	; 0x104c <__fixunssfsi>
     a62:	dc 01       	movw	r26, r24
     a64:	cb 01       	movw	r24, r22
     a66:	f8 01       	movw	r30, r16
     a68:	91 83       	std	Z+1, r25	; 0x01
     a6a:	80 83       	st	Z, r24
     a6c:	ce 01       	movw	r24, r28
     a6e:	87 5b       	subi	r24, 0xB7	; 183
     a70:	9f 4f       	sbci	r25, 0xFF	; 255
     a72:	9e 01       	movw	r18, r28
     a74:	2b 5b       	subi	r18, 0xBB	; 187
     a76:	3f 4f       	sbci	r19, 0xFF	; 255
     a78:	f9 01       	movw	r30, r18
     a7a:	20 81       	ld	r18, Z
     a7c:	31 81       	ldd	r19, Z+1	; 0x01
     a7e:	fc 01       	movw	r30, r24
     a80:	31 83       	std	Z+1, r19	; 0x01
     a82:	20 83       	st	Z, r18
     a84:	ce 01       	movw	r24, r28
     a86:	87 5b       	subi	r24, 0xB7	; 183
     a88:	9f 4f       	sbci	r25, 0xFF	; 255
     a8a:	fc 01       	movw	r30, r24
     a8c:	80 81       	ld	r24, Z
     a8e:	91 81       	ldd	r25, Z+1	; 0x01
     a90:	01 97       	sbiw	r24, 0x01	; 1
     a92:	f1 f7       	brne	.-4      	; 0xa90 <__stack+0x191>
     a94:	9e 01       	movw	r18, r28
     a96:	27 5b       	subi	r18, 0xB7	; 183
     a98:	3f 4f       	sbci	r19, 0xFF	; 255
     a9a:	f9 01       	movw	r30, r18
     a9c:	91 83       	std	Z+1, r25	; 0x01
     a9e:	80 83       	st	Z, r24
            _delay_ms(500);
            PORTB = 0x00;
     aa0:	85 e2       	ldi	r24, 0x25	; 37
     aa2:	90 e0       	ldi	r25, 0x00	; 0
     aa4:	fc 01       	movw	r30, r24
     aa6:	10 82       	st	Z, r1
        }
        
        // execute
        switch (mode) {
     aa8:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <mode.1739>
     aac:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <mode.1739+0x1>
     ab0:	82 30       	cpi	r24, 0x02	; 2
     ab2:	91 05       	cpc	r25, r1
     ab4:	71 f0       	breq	.+28     	; 0xad2 <__stack+0x1d3>
     ab6:	83 30       	cpi	r24, 0x03	; 3
     ab8:	91 05       	cpc	r25, r1
     aba:	1c f4       	brge	.+6      	; 0xac2 <__stack+0x1c3>
     abc:	01 97       	sbiw	r24, 0x01	; 1
     abe:	39 f0       	breq	.+14     	; 0xace <__stack+0x1cf>
     ac0:	0d c0       	rjmp	.+26     	; 0xadc <__stack+0x1dd>
     ac2:	83 30       	cpi	r24, 0x03	; 3
     ac4:	91 05       	cpc	r25, r1
     ac6:	39 f0       	breq	.+14     	; 0xad6 <__stack+0x1d7>
     ac8:	04 97       	sbiw	r24, 0x04	; 4
     aca:	31 f0       	breq	.+12     	; 0xad8 <__stack+0x1d9>
     acc:	07 c0       	rjmp	.+14     	; 0xadc <__stack+0x1dd>
            case 1:
                testTasterLed();
     ace:	78 d2       	rcall	.+1264   	; 0xfc0 <testTasterLed>
     ad0:	0a c0       	rjmp	.+20     	; 0xae6 <__stack+0x1e7>
                break;
     ad2:	6f d1       	rcall	.+734    	; 0xdb2 <testBoard>
            case 2:
                testBoard();
     ad4:	08 c0       	rjmp	.+16     	; 0xae6 <__stack+0x1e7>
     ad6:	14 d0       	rcall	.+40     	; 0xb00 <lauflicht>
                break;
     ad8:	ef d0       	rcall	.+478    	; 0xcb8 <increment>
            case 3:
                lauflicht();
     ada:	05 c0       	rjmp	.+10     	; 0xae6 <__stack+0x1e7>
     adc:	10 92 03 01 	sts	0x0103, r1	; 0x800103 <mode.1739+0x1>
            case 4:
                increment();
     ae0:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <mode.1739>
                break;
            default:
                mode = 0;
     ae4:	00 00       	nop
     ae6:	00 00       	nop
     ae8:	cc 5a       	subi	r28, 0xAC	; 172
     aea:	df 4f       	sbci	r29, 0xFF	; 255
                break;
     aec:	0f b6       	in	r0, 0x3f	; 63
        }
    }
}
     aee:	f8 94       	cli
     af0:	de bf       	out	0x3e, r29	; 62
     af2:	0f be       	out	0x3f, r0	; 63
     af4:	cd bf       	out	0x3d, r28	; 61
     af6:	df 91       	pop	r29
     af8:	cf 91       	pop	r28
     afa:	1f 91       	pop	r17
     afc:	0f 91       	pop	r16
     afe:	08 95       	ret

00000b00 <lauflicht>:
     b00:	cf 93       	push	r28
     b02:	df 93       	push	r29
     b04:	cd b7       	in	r28, 0x3d	; 61
     b06:	de b7       	in	r29, 0x3e	; 62
 Starting at Led0, the Led next to the current led will turn on at the same time the current led turns off.
 If last led is reached, the direction will change
 
 Only one led is active at once
 */
void lauflicht() {
     b08:	60 97       	sbiw	r28, 0x10	; 16
     b0a:	0f b6       	in	r0, 0x3f	; 63
     b0c:	f8 94       	cli
     b0e:	de bf       	out	0x3e, r29	; 62
     b10:	0f be       	out	0x3f, r0	; 63
     b12:	cd bf       	out	0x3d, r28	; 61
    static int laufCount = 0;
    static int direction = 0;   // 0=right, 1=left
    
    if (direction) {    // left
     b14:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <direction.1779>
     b18:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <direction.1779+0x1>
     b1c:	89 2b       	or	r24, r25
     b1e:	f1 f0       	breq	.+60     	; 0xb5c <lauflicht+0x5c>
        if (laufCount <= 1) {
     b20:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <laufCount.1778>
     b24:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <laufCount.1778+0x1>
     b28:	02 97       	sbiw	r24, 0x02	; 2
     b2a:	74 f4       	brge	.+28     	; 0xb48 <lauflicht+0x48>
            direction = 0;
     b2c:	10 92 05 01 	sts	0x0105, r1	; 0x800105 <direction.1779+0x1>
     b30:	10 92 04 01 	sts	0x0104, r1	; 0x800104 <direction.1779>
            laufCount++;
     b34:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <laufCount.1778>
     b38:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <laufCount.1778+0x1>
     b3c:	01 96       	adiw	r24, 0x01	; 1
     b3e:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <laufCount.1778+0x1>
     b42:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <laufCount.1778>
     b46:	29 c0       	rjmp	.+82     	; 0xb9a <lauflicht+0x9a>
        } else {
            laufCount--;
     b48:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <laufCount.1778>
     b4c:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <laufCount.1778+0x1>
     b50:	01 97       	sbiw	r24, 0x01	; 1
     b52:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <laufCount.1778+0x1>
     b56:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <laufCount.1778>
     b5a:	1f c0       	rjmp	.+62     	; 0xb9a <lauflicht+0x9a>
        }
    }else { // right
        if (laufCount >= 8) {
     b5c:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <laufCount.1778>
     b60:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <laufCount.1778+0x1>
     b64:	08 97       	sbiw	r24, 0x08	; 8
     b66:	84 f0       	brlt	.+32     	; 0xb88 <lauflicht+0x88>
            direction = 1;
     b68:	81 e0       	ldi	r24, 0x01	; 1
     b6a:	90 e0       	ldi	r25, 0x00	; 0
     b6c:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <direction.1779+0x1>
     b70:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <direction.1779>
            laufCount--;
     b74:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <laufCount.1778>
     b78:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <laufCount.1778+0x1>
     b7c:	01 97       	sbiw	r24, 0x01	; 1
     b7e:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <laufCount.1778+0x1>
     b82:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <laufCount.1778>
     b86:	09 c0       	rjmp	.+18     	; 0xb9a <lauflicht+0x9a>
        } else {
            laufCount++;
     b88:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <laufCount.1778>
     b8c:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <laufCount.1778+0x1>
     b90:	01 96       	adiw	r24, 0x01	; 1
     b92:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <laufCount.1778+0x1>
     b96:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <laufCount.1778>
        }
    }
    
    // create byte
    int ledByte = 1;
     b9a:	81 e0       	ldi	r24, 0x01	; 1
     b9c:	90 e0       	ldi	r25, 0x00	; 0
     b9e:	9a 83       	std	Y+2, r25	; 0x02
     ba0:	89 83       	std	Y+1, r24	; 0x01
    ledByte = ledByte << (laufCount - 1);
     ba2:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <laufCount.1778>
     ba6:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <laufCount.1778+0x1>
     baa:	9c 01       	movw	r18, r24
     bac:	21 50       	subi	r18, 0x01	; 1
     bae:	31 09       	sbc	r19, r1
     bb0:	89 81       	ldd	r24, Y+1	; 0x01
     bb2:	9a 81       	ldd	r25, Y+2	; 0x02
     bb4:	02 c0       	rjmp	.+4      	; 0xbba <lauflicht+0xba>
     bb6:	88 0f       	add	r24, r24
     bb8:	99 1f       	adc	r25, r25
     bba:	2a 95       	dec	r18
     bbc:	e2 f7       	brpl	.-8      	; 0xbb6 <lauflicht+0xb6>
     bbe:	9a 83       	std	Y+2, r25	; 0x02
     bc0:	89 83       	std	Y+1, r24	; 0x01
    
    // set Port
    PORTB = ledByte;
     bc2:	85 e2       	ldi	r24, 0x25	; 37
     bc4:	90 e0       	ldi	r25, 0x00	; 0
     bc6:	29 81       	ldd	r18, Y+1	; 0x01
     bc8:	fc 01       	movw	r30, r24
     bca:	20 83       	st	Z, r18
     bcc:	80 e0       	ldi	r24, 0x00	; 0
     bce:	90 e0       	ldi	r25, 0x00	; 0
     bd0:	a8 e4       	ldi	r26, 0x48	; 72
     bd2:	b3 e4       	ldi	r27, 0x43	; 67
     bd4:	8b 83       	std	Y+3, r24	; 0x03
     bd6:	9c 83       	std	Y+4, r25	; 0x04
     bd8:	ad 83       	std	Y+5, r26	; 0x05
     bda:	be 83       	std	Y+6, r27	; 0x06

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     bdc:	20 e0       	ldi	r18, 0x00	; 0
     bde:	30 e0       	ldi	r19, 0x00	; 0
     be0:	4a e7       	ldi	r20, 0x7A	; 122
     be2:	53 e4       	ldi	r21, 0x43	; 67
     be4:	6b 81       	ldd	r22, Y+3	; 0x03
     be6:	7c 81       	ldd	r23, Y+4	; 0x04
     be8:	8d 81       	ldd	r24, Y+5	; 0x05
     bea:	9e 81       	ldd	r25, Y+6	; 0x06
     bec:	ac d2       	rcall	.+1368   	; 0x1146 <__mulsf3>
     bee:	dc 01       	movw	r26, r24
     bf0:	cb 01       	movw	r24, r22
     bf2:	8f 83       	std	Y+7, r24	; 0x07
     bf4:	98 87       	std	Y+8, r25	; 0x08
     bf6:	a9 87       	std	Y+9, r26	; 0x09
     bf8:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     bfa:	20 e0       	ldi	r18, 0x00	; 0
     bfc:	30 e0       	ldi	r19, 0x00	; 0
     bfe:	40 e8       	ldi	r20, 0x80	; 128
     c00:	5f e3       	ldi	r21, 0x3F	; 63
     c02:	6f 81       	ldd	r22, Y+7	; 0x07
     c04:	78 85       	ldd	r23, Y+8	; 0x08
     c06:	89 85       	ldd	r24, Y+9	; 0x09
     c08:	9a 85       	ldd	r25, Y+10	; 0x0a
     c0a:	1c d2       	rcall	.+1080   	; 0x1044 <__cmpsf2>
     c0c:	88 23       	and	r24, r24
     c0e:	2c f4       	brge	.+10     	; 0xc1a <lauflicht+0x11a>
		__ticks = 1;
     c10:	81 e0       	ldi	r24, 0x01	; 1
     c12:	90 e0       	ldi	r25, 0x00	; 0
     c14:	9c 87       	std	Y+12, r25	; 0x0c
     c16:	8b 87       	std	Y+11, r24	; 0x0b
     c18:	3b c0       	rjmp	.+118    	; 0xc90 <lauflicht+0x190>
	else if (__tmp > 65535)
     c1a:	20 e0       	ldi	r18, 0x00	; 0
     c1c:	3f ef       	ldi	r19, 0xFF	; 255
     c1e:	4f e7       	ldi	r20, 0x7F	; 127
     c20:	57 e4       	ldi	r21, 0x47	; 71
     c22:	6f 81       	ldd	r22, Y+7	; 0x07
     c24:	78 85       	ldd	r23, Y+8	; 0x08
     c26:	89 85       	ldd	r24, Y+9	; 0x09
     c28:	9a 85       	ldd	r25, Y+10	; 0x0a
     c2a:	89 d2       	rcall	.+1298   	; 0x113e <__gesf2>
     c2c:	18 16       	cp	r1, r24
     c2e:	3c f5       	brge	.+78     	; 0xc7e <lauflicht+0x17e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     c30:	20 e0       	ldi	r18, 0x00	; 0
     c32:	30 e0       	ldi	r19, 0x00	; 0
     c34:	40 e2       	ldi	r20, 0x20	; 32
     c36:	51 e4       	ldi	r21, 0x41	; 65
     c38:	6b 81       	ldd	r22, Y+3	; 0x03
     c3a:	7c 81       	ldd	r23, Y+4	; 0x04
     c3c:	8d 81       	ldd	r24, Y+5	; 0x05
     c3e:	9e 81       	ldd	r25, Y+6	; 0x06
     c40:	82 d2       	rcall	.+1284   	; 0x1146 <__mulsf3>
     c42:	dc 01       	movw	r26, r24
     c44:	cb 01       	movw	r24, r22
     c46:	bc 01       	movw	r22, r24
     c48:	cd 01       	movw	r24, r26
     c4a:	00 d2       	rcall	.+1024   	; 0x104c <__fixunssfsi>
     c4c:	dc 01       	movw	r26, r24
     c4e:	cb 01       	movw	r24, r22
     c50:	9c 87       	std	Y+12, r25	; 0x0c
     c52:	8b 87       	std	Y+11, r24	; 0x0b
     c54:	0f c0       	rjmp	.+30     	; 0xc74 <lauflicht+0x174>
     c56:	89 e1       	ldi	r24, 0x19	; 25
     c58:	90 e0       	ldi	r25, 0x00	; 0
     c5a:	9e 87       	std	Y+14, r25	; 0x0e
     c5c:	8d 87       	std	Y+13, r24	; 0x0d
     c5e:	8d 85       	ldd	r24, Y+13	; 0x0d
     c60:	9e 85       	ldd	r25, Y+14	; 0x0e
     c62:	01 97       	sbiw	r24, 0x01	; 1
     c64:	f1 f7       	brne	.-4      	; 0xc62 <lauflicht+0x162>
     c66:	9e 87       	std	Y+14, r25	; 0x0e
     c68:	8d 87       	std	Y+13, r24	; 0x0d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     c6a:	8b 85       	ldd	r24, Y+11	; 0x0b
     c6c:	9c 85       	ldd	r25, Y+12	; 0x0c
     c6e:	01 97       	sbiw	r24, 0x01	; 1
     c70:	9c 87       	std	Y+12, r25	; 0x0c
     c72:	8b 87       	std	Y+11, r24	; 0x0b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     c74:	8b 85       	ldd	r24, Y+11	; 0x0b
     c76:	9c 85       	ldd	r25, Y+12	; 0x0c
     c78:	89 2b       	or	r24, r25
     c7a:	69 f7       	brne	.-38     	; 0xc56 <lauflicht+0x156>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     c7c:	13 c0       	rjmp	.+38     	; 0xca4 <lauflicht+0x1a4>
     c7e:	6f 81       	ldd	r22, Y+7	; 0x07
     c80:	78 85       	ldd	r23, Y+8	; 0x08
     c82:	89 85       	ldd	r24, Y+9	; 0x09
     c84:	9a 85       	ldd	r25, Y+10	; 0x0a
     c86:	e2 d1       	rcall	.+964    	; 0x104c <__fixunssfsi>
     c88:	dc 01       	movw	r26, r24
     c8a:	cb 01       	movw	r24, r22
     c8c:	9c 87       	std	Y+12, r25	; 0x0c
     c8e:	8b 87       	std	Y+11, r24	; 0x0b
     c90:	8b 85       	ldd	r24, Y+11	; 0x0b
     c92:	9c 85       	ldd	r25, Y+12	; 0x0c
     c94:	98 8b       	std	Y+16, r25	; 0x10
     c96:	8f 87       	std	Y+15, r24	; 0x0f
     c98:	8f 85       	ldd	r24, Y+15	; 0x0f
     c9a:	98 89       	ldd	r25, Y+16	; 0x10
     c9c:	01 97       	sbiw	r24, 0x01	; 1
     c9e:	f1 f7       	brne	.-4      	; 0xc9c <lauflicht+0x19c>
     ca0:	98 8b       	std	Y+16, r25	; 0x10
     ca2:	8f 87       	std	Y+15, r24	; 0x0f
    _delay_ms(200);
}
     ca4:	00 00       	nop
     ca6:	60 96       	adiw	r28, 0x10	; 16
     ca8:	0f b6       	in	r0, 0x3f	; 63
     caa:	f8 94       	cli
     cac:	de bf       	out	0x3e, r29	; 62
     cae:	0f be       	out	0x3f, r0	; 63
     cb0:	cd bf       	out	0x3d, r28	; 61
     cb2:	df 91       	pop	r29
     cb4:	cf 91       	pop	r28
     cb6:	08 95       	ret

00000cb8 <increment>:

/**
 Increment if button 1 is pressed, decrement if button 2 is pressed.
 Value of count will display with leds. if count is dez 5, 5 leds will turn on
 */
void increment() {
     cb8:	cf 93       	push	r28
     cba:	df 93       	push	r29
     cbc:	00 d0       	rcall	.+0      	; 0xcbe <increment+0x6>
     cbe:	00 d0       	rcall	.+0      	; 0xcc0 <increment+0x8>
     cc0:	cd b7       	in	r28, 0x3d	; 61
     cc2:	de b7       	in	r29, 0x3e	; 62
    static int count = 0;
    static int lockt1 = 0, lockt2 = 0;
    
    // If button is pressed and lock is released
    if (!lockt1 && Taster1_get()) {
     cc4:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <lockt1.1784>
     cc8:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <lockt1.1784+0x1>
     ccc:	89 2b       	or	r24, r25
     cce:	c9 f4       	brne	.+50     	; 0xd02 <increment+0x4a>
     cd0:	c4 da       	rcall	.-2680   	; 0x25a <Taster1_get>
     cd2:	89 2b       	or	r24, r25
     cd4:	b1 f0       	breq	.+44     	; 0xd02 <increment+0x4a>
        //count to max 8
        if (count <= 8) {
     cd6:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <count.1783>
     cda:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <count.1783+0x1>
     cde:	09 97       	sbiw	r24, 0x09	; 9
     ce0:	4c f4       	brge	.+18     	; 0xcf4 <increment+0x3c>
            count++;
     ce2:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <count.1783>
     ce6:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <count.1783+0x1>
     cea:	01 96       	adiw	r24, 0x01	; 1
     cec:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <count.1783+0x1>
     cf0:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <count.1783>
        }
        // lock
        lockt1 = 1;
     cf4:	81 e0       	ldi	r24, 0x01	; 1
     cf6:	90 e0       	ldi	r25, 0x00	; 0
     cf8:	90 93 09 01 	sts	0x0109, r25	; 0x800109 <lockt1.1784+0x1>
     cfc:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <lockt1.1784>
     d00:	1f c0       	rjmp	.+62     	; 0xd40 <increment+0x88>
    }else if (!lockt2 && Taster2_get()) {
     d02:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <lockt2.1785>
     d06:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <lockt2.1785+0x1>
     d0a:	89 2b       	or	r24, r25
     d0c:	c9 f4       	brne	.+50     	; 0xd40 <increment+0x88>
     d0e:	c0 da       	rcall	.-2688   	; 0x290 <Taster2_get>
     d10:	89 2b       	or	r24, r25
     d12:	b1 f0       	breq	.+44     	; 0xd40 <increment+0x88>
        //count to min 0
        if (count > 0) {
     d14:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <count.1783>
     d18:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <count.1783+0x1>
     d1c:	18 16       	cp	r1, r24
     d1e:	19 06       	cpc	r1, r25
     d20:	4c f4       	brge	.+18     	; 0xd34 <increment+0x7c>
            count--;
     d22:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <count.1783>
     d26:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <count.1783+0x1>
     d2a:	01 97       	sbiw	r24, 0x01	; 1
     d2c:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <count.1783+0x1>
     d30:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <count.1783>
        }
        // lock
        lockt2 = 1;
     d34:	81 e0       	ldi	r24, 0x01	; 1
     d36:	90 e0       	ldi	r25, 0x00	; 0
     d38:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <lockt2.1785+0x1>
     d3c:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <lockt2.1785>
    }
    
    // if button is released, release lock
    if (!Taster1_get()) {
     d40:	8c da       	rcall	.-2792   	; 0x25a <Taster1_get>
     d42:	89 2b       	or	r24, r25
     d44:	21 f4       	brne	.+8      	; 0xd4e <increment+0x96>
        lockt1 = 0;
     d46:	10 92 09 01 	sts	0x0109, r1	; 0x800109 <lockt1.1784+0x1>
     d4a:	10 92 08 01 	sts	0x0108, r1	; 0x800108 <lockt1.1784>
    }
    if (!Taster2_get()) {
     d4e:	a0 da       	rcall	.-2752   	; 0x290 <Taster2_get>
     d50:	89 2b       	or	r24, r25
     d52:	21 f4       	brne	.+8      	; 0xd5c <increment+0xa4>
        lockt2 = 0;
     d54:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <lockt2.1785+0x1>
     d58:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <lockt2.1785>
    }
    
    // shift as many ones as count to byte
    int ledByte = 0;
     d5c:	1a 82       	std	Y+2, r1	; 0x02
     d5e:	19 82       	std	Y+1, r1	; 0x01
    for (int i = 0; i < count; i++) {
     d60:	1c 82       	std	Y+4, r1	; 0x04
     d62:	1b 82       	std	Y+3, r1	; 0x03
     d64:	10 c0       	rjmp	.+32     	; 0xd86 <increment+0xce>
        ledByte = ledByte << 1;
     d66:	89 81       	ldd	r24, Y+1	; 0x01
     d68:	9a 81       	ldd	r25, Y+2	; 0x02
     d6a:	88 0f       	add	r24, r24
     d6c:	99 1f       	adc	r25, r25
     d6e:	9a 83       	std	Y+2, r25	; 0x02
     d70:	89 83       	std	Y+1, r24	; 0x01
        ledByte++;
     d72:	89 81       	ldd	r24, Y+1	; 0x01
     d74:	9a 81       	ldd	r25, Y+2	; 0x02
     d76:	01 96       	adiw	r24, 0x01	; 1
     d78:	9a 83       	std	Y+2, r25	; 0x02
     d7a:	89 83       	std	Y+1, r24	; 0x01
        lockt2 = 0;
    }
    
    // shift as many ones as count to byte
    int ledByte = 0;
    for (int i = 0; i < count; i++) {
     d7c:	8b 81       	ldd	r24, Y+3	; 0x03
     d7e:	9c 81       	ldd	r25, Y+4	; 0x04
     d80:	01 96       	adiw	r24, 0x01	; 1
     d82:	9c 83       	std	Y+4, r25	; 0x04
     d84:	8b 83       	std	Y+3, r24	; 0x03
     d86:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <count.1783>
     d8a:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <count.1783+0x1>
     d8e:	2b 81       	ldd	r18, Y+3	; 0x03
     d90:	3c 81       	ldd	r19, Y+4	; 0x04
     d92:	28 17       	cp	r18, r24
     d94:	39 07       	cpc	r19, r25
     d96:	3c f3       	brlt	.-50     	; 0xd66 <increment+0xae>
        ledByte = ledByte << 1;
        ledByte++;
    }
    // set Port
    PORTB = ledByte;
     d98:	85 e2       	ldi	r24, 0x25	; 37
     d9a:	90 e0       	ldi	r25, 0x00	; 0
     d9c:	29 81       	ldd	r18, Y+1	; 0x01
     d9e:	fc 01       	movw	r30, r24
     da0:	20 83       	st	Z, r18
}
     da2:	00 00       	nop
     da4:	0f 90       	pop	r0
     da6:	0f 90       	pop	r0
     da8:	0f 90       	pop	r0
     daa:	0f 90       	pop	r0
     dac:	df 91       	pop	r29
     dae:	cf 91       	pop	r28
     db0:	08 95       	ret

00000db2 <testBoard>:

/**
 Switches PORTB on and off with a delay off 500 ms
 */
void testBoard() {
     db2:	cf 93       	push	r28
     db4:	df 93       	push	r29
     db6:	cd b7       	in	r28, 0x3d	; 61
     db8:	de b7       	in	r29, 0x3e	; 62
     dba:	6c 97       	sbiw	r28, 0x1c	; 28
     dbc:	0f b6       	in	r0, 0x3f	; 63
     dbe:	f8 94       	cli
     dc0:	de bf       	out	0x3e, r29	; 62
     dc2:	0f be       	out	0x3f, r0	; 63
     dc4:	cd bf       	out	0x3d, r28	; 61
    static int state_testBoard = 0;
    if (state_testBoard) {
     dc6:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <state_testBoard.1797>
     dca:	90 91 0f 01 	lds	r25, 0x010F	; 0x80010f <state_testBoard.1797+0x1>
     dce:	89 2b       	or	r24, r25
     dd0:	09 f4       	brne	.+2      	; 0xdd4 <testBoard+0x22>
     dd2:	75 c0       	rjmp	.+234    	; 0xebe <testBoard+0x10c>
		state_testBoard = 0;
     dd4:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <state_testBoard.1797+0x1>
     dd8:	10 92 0e 01 	sts	0x010E, r1	; 0x80010e <state_testBoard.1797>
        PORTB = 0x00;
     ddc:	85 e2       	ldi	r24, 0x25	; 37
     dde:	90 e0       	ldi	r25, 0x00	; 0
     de0:	fc 01       	movw	r30, r24
     de2:	10 82       	st	Z, r1
     de4:	80 e0       	ldi	r24, 0x00	; 0
     de6:	90 e0       	ldi	r25, 0x00	; 0
     de8:	aa ef       	ldi	r26, 0xFA	; 250
     dea:	b3 e4       	ldi	r27, 0x43	; 67
     dec:	8d 83       	std	Y+5, r24	; 0x05
     dee:	9e 83       	std	Y+6, r25	; 0x06
     df0:	af 83       	std	Y+7, r26	; 0x07
     df2:	b8 87       	std	Y+8, r27	; 0x08

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     df4:	20 e0       	ldi	r18, 0x00	; 0
     df6:	30 e0       	ldi	r19, 0x00	; 0
     df8:	4a e7       	ldi	r20, 0x7A	; 122
     dfa:	53 e4       	ldi	r21, 0x43	; 67
     dfc:	6d 81       	ldd	r22, Y+5	; 0x05
     dfe:	7e 81       	ldd	r23, Y+6	; 0x06
     e00:	8f 81       	ldd	r24, Y+7	; 0x07
     e02:	98 85       	ldd	r25, Y+8	; 0x08
     e04:	a0 d1       	rcall	.+832    	; 0x1146 <__mulsf3>
     e06:	dc 01       	movw	r26, r24
     e08:	cb 01       	movw	r24, r22
     e0a:	89 87       	std	Y+9, r24	; 0x09
     e0c:	9a 87       	std	Y+10, r25	; 0x0a
     e0e:	ab 87       	std	Y+11, r26	; 0x0b
     e10:	bc 87       	std	Y+12, r27	; 0x0c
	if (__tmp < 1.0)
     e12:	20 e0       	ldi	r18, 0x00	; 0
     e14:	30 e0       	ldi	r19, 0x00	; 0
     e16:	40 e8       	ldi	r20, 0x80	; 128
     e18:	5f e3       	ldi	r21, 0x3F	; 63
     e1a:	69 85       	ldd	r22, Y+9	; 0x09
     e1c:	7a 85       	ldd	r23, Y+10	; 0x0a
     e1e:	8b 85       	ldd	r24, Y+11	; 0x0b
     e20:	9c 85       	ldd	r25, Y+12	; 0x0c
     e22:	10 d1       	rcall	.+544    	; 0x1044 <__cmpsf2>
     e24:	88 23       	and	r24, r24
     e26:	2c f4       	brge	.+10     	; 0xe32 <testBoard+0x80>
		__ticks = 1;
     e28:	81 e0       	ldi	r24, 0x01	; 1
     e2a:	90 e0       	ldi	r25, 0x00	; 0
     e2c:	9e 87       	std	Y+14, r25	; 0x0e
     e2e:	8d 87       	std	Y+13, r24	; 0x0d
     e30:	3b c0       	rjmp	.+118    	; 0xea8 <testBoard+0xf6>
	else if (__tmp > 65535)
     e32:	20 e0       	ldi	r18, 0x00	; 0
     e34:	3f ef       	ldi	r19, 0xFF	; 255
     e36:	4f e7       	ldi	r20, 0x7F	; 127
     e38:	57 e4       	ldi	r21, 0x47	; 71
     e3a:	69 85       	ldd	r22, Y+9	; 0x09
     e3c:	7a 85       	ldd	r23, Y+10	; 0x0a
     e3e:	8b 85       	ldd	r24, Y+11	; 0x0b
     e40:	9c 85       	ldd	r25, Y+12	; 0x0c
     e42:	7d d1       	rcall	.+762    	; 0x113e <__gesf2>
     e44:	18 16       	cp	r1, r24
     e46:	3c f5       	brge	.+78     	; 0xe96 <testBoard+0xe4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     e48:	20 e0       	ldi	r18, 0x00	; 0
     e4a:	30 e0       	ldi	r19, 0x00	; 0
     e4c:	40 e2       	ldi	r20, 0x20	; 32
     e4e:	51 e4       	ldi	r21, 0x41	; 65
     e50:	6d 81       	ldd	r22, Y+5	; 0x05
     e52:	7e 81       	ldd	r23, Y+6	; 0x06
     e54:	8f 81       	ldd	r24, Y+7	; 0x07
     e56:	98 85       	ldd	r25, Y+8	; 0x08
     e58:	76 d1       	rcall	.+748    	; 0x1146 <__mulsf3>
     e5a:	dc 01       	movw	r26, r24
     e5c:	cb 01       	movw	r24, r22
     e5e:	bc 01       	movw	r22, r24
     e60:	cd 01       	movw	r24, r26
     e62:	f4 d0       	rcall	.+488    	; 0x104c <__fixunssfsi>
     e64:	dc 01       	movw	r26, r24
     e66:	cb 01       	movw	r24, r22
     e68:	9e 87       	std	Y+14, r25	; 0x0e
     e6a:	8d 87       	std	Y+13, r24	; 0x0d
     e6c:	0f c0       	rjmp	.+30     	; 0xe8c <testBoard+0xda>
     e6e:	89 e1       	ldi	r24, 0x19	; 25
     e70:	90 e0       	ldi	r25, 0x00	; 0
     e72:	98 8b       	std	Y+16, r25	; 0x10
     e74:	8f 87       	std	Y+15, r24	; 0x0f
     e76:	8f 85       	ldd	r24, Y+15	; 0x0f
     e78:	98 89       	ldd	r25, Y+16	; 0x10
     e7a:	01 97       	sbiw	r24, 0x01	; 1
     e7c:	f1 f7       	brne	.-4      	; 0xe7a <testBoard+0xc8>
     e7e:	98 8b       	std	Y+16, r25	; 0x10
     e80:	8f 87       	std	Y+15, r24	; 0x0f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     e82:	8d 85       	ldd	r24, Y+13	; 0x0d
     e84:	9e 85       	ldd	r25, Y+14	; 0x0e
     e86:	01 97       	sbiw	r24, 0x01	; 1
     e88:	9e 87       	std	Y+14, r25	; 0x0e
     e8a:	8d 87       	std	Y+13, r24	; 0x0d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     e8c:	8d 85       	ldd	r24, Y+13	; 0x0d
     e8e:	9e 85       	ldd	r25, Y+14	; 0x0e
     e90:	89 2b       	or	r24, r25
     e92:	69 f7       	brne	.-38     	; 0xe6e <testBoard+0xbc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     e94:	8b c0       	rjmp	.+278    	; 0xfac <testBoard+0x1fa>
     e96:	69 85       	ldd	r22, Y+9	; 0x09
     e98:	7a 85       	ldd	r23, Y+10	; 0x0a
     e9a:	8b 85       	ldd	r24, Y+11	; 0x0b
     e9c:	9c 85       	ldd	r25, Y+12	; 0x0c
     e9e:	d6 d0       	rcall	.+428    	; 0x104c <__fixunssfsi>
     ea0:	dc 01       	movw	r26, r24
     ea2:	cb 01       	movw	r24, r22
     ea4:	9e 87       	std	Y+14, r25	; 0x0e
     ea6:	8d 87       	std	Y+13, r24	; 0x0d
     ea8:	8d 85       	ldd	r24, Y+13	; 0x0d
     eaa:	9e 85       	ldd	r25, Y+14	; 0x0e
     eac:	9a 8b       	std	Y+18, r25	; 0x12
     eae:	89 8b       	std	Y+17, r24	; 0x11
     eb0:	89 89       	ldd	r24, Y+17	; 0x11
     eb2:	9a 89       	ldd	r25, Y+18	; 0x12
     eb4:	01 97       	sbiw	r24, 0x01	; 1
     eb6:	f1 f7       	brne	.-4      	; 0xeb4 <testBoard+0x102>
     eb8:	9a 8b       	std	Y+18, r25	; 0x12
     eba:	89 8b       	std	Y+17, r24	; 0x11
    }else {
		state_testBoard = 1;
        PORTB = 0xFF;
        _delay_ms(500);
    }
}
     ebc:	77 c0       	rjmp	.+238    	; 0xfac <testBoard+0x1fa>
    if (state_testBoard) {
		state_testBoard = 0;
        PORTB = 0x00;
        _delay_ms(500);
    }else {
		state_testBoard = 1;
     ebe:	81 e0       	ldi	r24, 0x01	; 1
     ec0:	90 e0       	ldi	r25, 0x00	; 0
     ec2:	90 93 0f 01 	sts	0x010F, r25	; 0x80010f <state_testBoard.1797+0x1>
     ec6:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <state_testBoard.1797>
        PORTB = 0xFF;
     eca:	85 e2       	ldi	r24, 0x25	; 37
     ecc:	90 e0       	ldi	r25, 0x00	; 0
     ece:	2f ef       	ldi	r18, 0xFF	; 255
     ed0:	fc 01       	movw	r30, r24
     ed2:	20 83       	st	Z, r18
     ed4:	80 e0       	ldi	r24, 0x00	; 0
     ed6:	90 e0       	ldi	r25, 0x00	; 0
     ed8:	aa ef       	ldi	r26, 0xFA	; 250
     eda:	b3 e4       	ldi	r27, 0x43	; 67
     edc:	89 83       	std	Y+1, r24	; 0x01
     ede:	9a 83       	std	Y+2, r25	; 0x02
     ee0:	ab 83       	std	Y+3, r26	; 0x03
     ee2:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     ee4:	20 e0       	ldi	r18, 0x00	; 0
     ee6:	30 e0       	ldi	r19, 0x00	; 0
     ee8:	4a e7       	ldi	r20, 0x7A	; 122
     eea:	53 e4       	ldi	r21, 0x43	; 67
     eec:	69 81       	ldd	r22, Y+1	; 0x01
     eee:	7a 81       	ldd	r23, Y+2	; 0x02
     ef0:	8b 81       	ldd	r24, Y+3	; 0x03
     ef2:	9c 81       	ldd	r25, Y+4	; 0x04
     ef4:	28 d1       	rcall	.+592    	; 0x1146 <__mulsf3>
     ef6:	dc 01       	movw	r26, r24
     ef8:	cb 01       	movw	r24, r22
     efa:	8b 8b       	std	Y+19, r24	; 0x13
     efc:	9c 8b       	std	Y+20, r25	; 0x14
     efe:	ad 8b       	std	Y+21, r26	; 0x15
     f00:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
     f02:	20 e0       	ldi	r18, 0x00	; 0
     f04:	30 e0       	ldi	r19, 0x00	; 0
     f06:	40 e8       	ldi	r20, 0x80	; 128
     f08:	5f e3       	ldi	r21, 0x3F	; 63
     f0a:	6b 89       	ldd	r22, Y+19	; 0x13
     f0c:	7c 89       	ldd	r23, Y+20	; 0x14
     f0e:	8d 89       	ldd	r24, Y+21	; 0x15
     f10:	9e 89       	ldd	r25, Y+22	; 0x16
     f12:	98 d0       	rcall	.+304    	; 0x1044 <__cmpsf2>
     f14:	88 23       	and	r24, r24
     f16:	2c f4       	brge	.+10     	; 0xf22 <testBoard+0x170>
		__ticks = 1;
     f18:	81 e0       	ldi	r24, 0x01	; 1
     f1a:	90 e0       	ldi	r25, 0x00	; 0
     f1c:	98 8f       	std	Y+24, r25	; 0x18
     f1e:	8f 8b       	std	Y+23, r24	; 0x17
     f20:	3b c0       	rjmp	.+118    	; 0xf98 <testBoard+0x1e6>
	else if (__tmp > 65535)
     f22:	20 e0       	ldi	r18, 0x00	; 0
     f24:	3f ef       	ldi	r19, 0xFF	; 255
     f26:	4f e7       	ldi	r20, 0x7F	; 127
     f28:	57 e4       	ldi	r21, 0x47	; 71
     f2a:	6b 89       	ldd	r22, Y+19	; 0x13
     f2c:	7c 89       	ldd	r23, Y+20	; 0x14
     f2e:	8d 89       	ldd	r24, Y+21	; 0x15
     f30:	9e 89       	ldd	r25, Y+22	; 0x16
     f32:	05 d1       	rcall	.+522    	; 0x113e <__gesf2>
     f34:	18 16       	cp	r1, r24
     f36:	3c f5       	brge	.+78     	; 0xf86 <testBoard+0x1d4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     f38:	20 e0       	ldi	r18, 0x00	; 0
     f3a:	30 e0       	ldi	r19, 0x00	; 0
     f3c:	40 e2       	ldi	r20, 0x20	; 32
     f3e:	51 e4       	ldi	r21, 0x41	; 65
     f40:	69 81       	ldd	r22, Y+1	; 0x01
     f42:	7a 81       	ldd	r23, Y+2	; 0x02
     f44:	8b 81       	ldd	r24, Y+3	; 0x03
     f46:	9c 81       	ldd	r25, Y+4	; 0x04
     f48:	fe d0       	rcall	.+508    	; 0x1146 <__mulsf3>
     f4a:	dc 01       	movw	r26, r24
     f4c:	cb 01       	movw	r24, r22
     f4e:	bc 01       	movw	r22, r24
     f50:	cd 01       	movw	r24, r26
     f52:	7c d0       	rcall	.+248    	; 0x104c <__fixunssfsi>
     f54:	dc 01       	movw	r26, r24
     f56:	cb 01       	movw	r24, r22
     f58:	98 8f       	std	Y+24, r25	; 0x18
     f5a:	8f 8b       	std	Y+23, r24	; 0x17
     f5c:	0f c0       	rjmp	.+30     	; 0xf7c <testBoard+0x1ca>
     f5e:	89 e1       	ldi	r24, 0x19	; 25
     f60:	90 e0       	ldi	r25, 0x00	; 0
     f62:	9a 8f       	std	Y+26, r25	; 0x1a
     f64:	89 8f       	std	Y+25, r24	; 0x19
     f66:	89 8d       	ldd	r24, Y+25	; 0x19
     f68:	9a 8d       	ldd	r25, Y+26	; 0x1a
     f6a:	01 97       	sbiw	r24, 0x01	; 1
     f6c:	f1 f7       	brne	.-4      	; 0xf6a <testBoard+0x1b8>
     f6e:	9a 8f       	std	Y+26, r25	; 0x1a
     f70:	89 8f       	std	Y+25, r24	; 0x19
     f72:	8f 89       	ldd	r24, Y+23	; 0x17
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     f74:	98 8d       	ldd	r25, Y+24	; 0x18
     f76:	01 97       	sbiw	r24, 0x01	; 1
     f78:	98 8f       	std	Y+24, r25	; 0x18
     f7a:	8f 8b       	std	Y+23, r24	; 0x17
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     f7c:	8f 89       	ldd	r24, Y+23	; 0x17
     f7e:	98 8d       	ldd	r25, Y+24	; 0x18
     f80:	89 2b       	or	r24, r25
     f82:	69 f7       	brne	.-38     	; 0xf5e <testBoard+0x1ac>
        _delay_ms(500);
    }
}
     f84:	13 c0       	rjmp	.+38     	; 0xfac <testBoard+0x1fa>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     f86:	6b 89       	ldd	r22, Y+19	; 0x13
     f88:	7c 89       	ldd	r23, Y+20	; 0x14
     f8a:	8d 89       	ldd	r24, Y+21	; 0x15
     f8c:	9e 89       	ldd	r25, Y+22	; 0x16
     f8e:	5e d0       	rcall	.+188    	; 0x104c <__fixunssfsi>
     f90:	dc 01       	movw	r26, r24
     f92:	cb 01       	movw	r24, r22
     f94:	98 8f       	std	Y+24, r25	; 0x18
     f96:	8f 8b       	std	Y+23, r24	; 0x17
     f98:	8f 89       	ldd	r24, Y+23	; 0x17
     f9a:	98 8d       	ldd	r25, Y+24	; 0x18
     f9c:	9c 8f       	std	Y+28, r25	; 0x1c
     f9e:	8b 8f       	std	Y+27, r24	; 0x1b
     fa0:	8b 8d       	ldd	r24, Y+27	; 0x1b
     fa2:	9c 8d       	ldd	r25, Y+28	; 0x1c
     fa4:	01 97       	sbiw	r24, 0x01	; 1
     fa6:	f1 f7       	brne	.-4      	; 0xfa4 <testBoard+0x1f2>
     fa8:	9c 8f       	std	Y+28, r25	; 0x1c
     faa:	8b 8f       	std	Y+27, r24	; 0x1b
     fac:	00 00       	nop
     fae:	6c 96       	adiw	r28, 0x1c	; 28
     fb0:	0f b6       	in	r0, 0x3f	; 63
     fb2:	f8 94       	cli
     fb4:	de bf       	out	0x3e, r29	; 62
     fb6:	0f be       	out	0x3f, r0	; 63
     fb8:	cd bf       	out	0x3d, r28	; 61
     fba:	df 91       	pop	r29
     fbc:	cf 91       	pop	r28
     fbe:	08 95       	ret

00000fc0 <testTasterLed>:
     fc0:	cf 93       	push	r28

/**
 If button1 is pressed, led1 will turn on. If button2 is pressed, led2 will turn on and so on...
 */
void testTasterLed() {
     fc2:	df 93       	push	r29
     fc4:	cd b7       	in	r28, 0x3d	; 61
     fc6:	de b7       	in	r29, 0x3e	; 62
    if (Taster1_get()) {
     fc8:	48 d9       	rcall	.-3440   	; 0x25a <Taster1_get>
     fca:	89 2b       	or	r24, r25
     fcc:	11 f0       	breq	.+4      	; 0xfd2 <testTasterLed+0x12>
        Led1_On();
     fce:	6f d8       	rcall	.-3874   	; 0xae <Led1_On>
     fd0:	01 c0       	rjmp	.+2      	; 0xfd4 <testTasterLed+0x14>
    }else {
        Led1_Off();
     fd2:	7e d8       	rcall	.-3844   	; 0xd0 <Led1_Off>
     fd4:	5d d9       	rcall	.-3398   	; 0x290 <Taster2_get>
    }
    if (Taster2_get()) {
     fd6:	89 2b       	or	r24, r25
     fd8:	11 f0       	breq	.+4      	; 0xfde <testTasterLed+0x1e>
        Led2_On();
     fda:	8b d8       	rcall	.-3818   	; 0xf2 <Led2_On>
     fdc:	01 c0       	rjmp	.+2      	; 0xfe0 <testTasterLed+0x20>
    }else {
        Led2_Off();
     fde:	9a d8       	rcall	.-3788   	; 0x114 <Led2_Off>
    }
    if (Taster3_get()) {
     fe0:	6f d9       	rcall	.-3362   	; 0x2c0 <Taster3_get>
     fe2:	89 2b       	or	r24, r25
     fe4:	11 f0       	breq	.+4      	; 0xfea <testTasterLed+0x2a>
        Led3_On();
     fe6:	a7 d8       	rcall	.-3762   	; 0x136 <Led3_On>
     fe8:	01 c0       	rjmp	.+2      	; 0xfec <testTasterLed+0x2c>
        }else {
        Led3_Off();
     fea:	b6 d8       	rcall	.-3732   	; 0x158 <Led3_Off>
     fec:	81 d9       	rcall	.-3326   	; 0x2f0 <Taster4_get>
    }
    if (Taster4_get()) {
     fee:	89 2b       	or	r24, r25
     ff0:	11 f0       	breq	.+4      	; 0xff6 <testTasterLed+0x36>
     ff2:	c3 d8       	rcall	.-3706   	; 0x17a <Led4_On>
     ff4:	01 c0       	rjmp	.+2      	; 0xff8 <testTasterLed+0x38>
        Led4_On();
     ff6:	d2 d8       	rcall	.-3676   	; 0x19c <Led4_Off>
     ff8:	00 00       	nop
        }else {
        Led4_Off();
    }
}
     ffa:	df 91       	pop	r29
        Led3_Off();
    }
    if (Taster4_get()) {
        Led4_On();
        }else {
        Led4_Off();
     ffc:	cf 91       	pop	r28
     ffe:	08 95       	ret

00001000 <Timer_init>:

#include "Timer.h"

void Timer_init() {
    1000:	cf 93       	push	r28
    1002:	df 93       	push	r29
    1004:	cd b7       	in	r28, 0x3d	; 61
    1006:	de b7       	in	r29, 0x3e	; 62
    
    // set prescaler to 1
    TCCR0B &= ~( (1 << 2) | (1 << 1) );
    TCCR0B |= (1 << 0);*/
    
    TCCR0A = 0x00;
    1008:	84 e4       	ldi	r24, 0x44	; 68
    100a:	90 e0       	ldi	r25, 0x00	; 0
    100c:	fc 01       	movw	r30, r24
    100e:	10 82       	st	Z, r1
    TCCR0B = 0x00;
    1010:	85 e4       	ldi	r24, 0x45	; 69
    1012:	90 e0       	ldi	r25, 0x00	; 0
    1014:	fc 01       	movw	r30, r24
    1016:	10 82       	st	Z, r1
    TCCR0B |= (1 << 0);
    1018:	85 e4       	ldi	r24, 0x45	; 69
    101a:	90 e0       	ldi	r25, 0x00	; 0
    101c:	25 e4       	ldi	r18, 0x45	; 69
    101e:	30 e0       	ldi	r19, 0x00	; 0
    1020:	f9 01       	movw	r30, r18
    1022:	20 81       	ld	r18, Z
    1024:	21 60       	ori	r18, 0x01	; 1
    1026:	fc 01       	movw	r30, r24
    1028:	20 83       	st	Z, r18
	
	// enable interrupt
	TIMSK0 |= (1 << 0);
    102a:	8e e6       	ldi	r24, 0x6E	; 110
    102c:	90 e0       	ldi	r25, 0x00	; 0
    102e:	2e e6       	ldi	r18, 0x6E	; 110
    1030:	30 e0       	ldi	r19, 0x00	; 0
    1032:	f9 01       	movw	r30, r18
    1034:	20 81       	ld	r18, Z
    1036:	21 60       	ori	r18, 0x01	; 1
    1038:	fc 01       	movw	r30, r24
    103a:	20 83       	st	Z, r18
}
    103c:	00 00       	nop
    103e:	df 91       	pop	r29
    1040:	cf 91       	pop	r28
    1042:	08 95       	ret

00001044 <__cmpsf2>:
    1044:	2f d0       	rcall	.+94     	; 0x10a4 <__fp_cmp>
    1046:	08 f4       	brcc	.+2      	; 0x104a <__cmpsf2+0x6>
    1048:	81 e0       	ldi	r24, 0x01	; 1
    104a:	08 95       	ret

0000104c <__fixunssfsi>:
    104c:	57 d0       	rcall	.+174    	; 0x10fc <__fp_splitA>
    104e:	88 f0       	brcs	.+34     	; 0x1072 <__fixunssfsi+0x26>
    1050:	9f 57       	subi	r25, 0x7F	; 127
    1052:	90 f0       	brcs	.+36     	; 0x1078 <__fixunssfsi+0x2c>
    1054:	b9 2f       	mov	r27, r25
    1056:	99 27       	eor	r25, r25
    1058:	b7 51       	subi	r27, 0x17	; 23
    105a:	a0 f0       	brcs	.+40     	; 0x1084 <__fixunssfsi+0x38>
    105c:	d1 f0       	breq	.+52     	; 0x1092 <__fixunssfsi+0x46>
    105e:	66 0f       	add	r22, r22
    1060:	77 1f       	adc	r23, r23
    1062:	88 1f       	adc	r24, r24
    1064:	99 1f       	adc	r25, r25
    1066:	1a f0       	brmi	.+6      	; 0x106e <__fixunssfsi+0x22>
    1068:	ba 95       	dec	r27
    106a:	c9 f7       	brne	.-14     	; 0x105e <__fixunssfsi+0x12>
    106c:	12 c0       	rjmp	.+36     	; 0x1092 <__fixunssfsi+0x46>
    106e:	b1 30       	cpi	r27, 0x01	; 1
    1070:	81 f0       	breq	.+32     	; 0x1092 <__fixunssfsi+0x46>
    1072:	5e d0       	rcall	.+188    	; 0x1130 <__fp_zero>
    1074:	b1 e0       	ldi	r27, 0x01	; 1
    1076:	08 95       	ret
    1078:	5b c0       	rjmp	.+182    	; 0x1130 <__fp_zero>
    107a:	67 2f       	mov	r22, r23
    107c:	78 2f       	mov	r23, r24
    107e:	88 27       	eor	r24, r24
    1080:	b8 5f       	subi	r27, 0xF8	; 248
    1082:	39 f0       	breq	.+14     	; 0x1092 <__fixunssfsi+0x46>
    1084:	b9 3f       	cpi	r27, 0xF9	; 249
    1086:	cc f3       	brlt	.-14     	; 0x107a <__fixunssfsi+0x2e>
    1088:	86 95       	lsr	r24
    108a:	77 95       	ror	r23
    108c:	67 95       	ror	r22
    108e:	b3 95       	inc	r27
    1090:	d9 f7       	brne	.-10     	; 0x1088 <__fixunssfsi+0x3c>
    1092:	3e f4       	brtc	.+14     	; 0x10a2 <__fixunssfsi+0x56>
    1094:	90 95       	com	r25
    1096:	80 95       	com	r24
    1098:	70 95       	com	r23
    109a:	61 95       	neg	r22
    109c:	7f 4f       	sbci	r23, 0xFF	; 255
    109e:	8f 4f       	sbci	r24, 0xFF	; 255
    10a0:	9f 4f       	sbci	r25, 0xFF	; 255
    10a2:	08 95       	ret

000010a4 <__fp_cmp>:
    10a4:	99 0f       	add	r25, r25
    10a6:	00 08       	sbc	r0, r0
    10a8:	55 0f       	add	r21, r21
    10aa:	aa 0b       	sbc	r26, r26
    10ac:	e0 e8       	ldi	r30, 0x80	; 128
    10ae:	fe ef       	ldi	r31, 0xFE	; 254
    10b0:	16 16       	cp	r1, r22
    10b2:	17 06       	cpc	r1, r23
    10b4:	e8 07       	cpc	r30, r24
    10b6:	f9 07       	cpc	r31, r25
    10b8:	c0 f0       	brcs	.+48     	; 0x10ea <__fp_cmp+0x46>
    10ba:	12 16       	cp	r1, r18
    10bc:	13 06       	cpc	r1, r19
    10be:	e4 07       	cpc	r30, r20
    10c0:	f5 07       	cpc	r31, r21
    10c2:	98 f0       	brcs	.+38     	; 0x10ea <__fp_cmp+0x46>
    10c4:	62 1b       	sub	r22, r18
    10c6:	73 0b       	sbc	r23, r19
    10c8:	84 0b       	sbc	r24, r20
    10ca:	95 0b       	sbc	r25, r21
    10cc:	39 f4       	brne	.+14     	; 0x10dc <__fp_cmp+0x38>
    10ce:	0a 26       	eor	r0, r26
    10d0:	61 f0       	breq	.+24     	; 0x10ea <__fp_cmp+0x46>
    10d2:	23 2b       	or	r18, r19
    10d4:	24 2b       	or	r18, r20
    10d6:	25 2b       	or	r18, r21
    10d8:	21 f4       	brne	.+8      	; 0x10e2 <__fp_cmp+0x3e>
    10da:	08 95       	ret
    10dc:	0a 26       	eor	r0, r26
    10de:	09 f4       	brne	.+2      	; 0x10e2 <__fp_cmp+0x3e>
    10e0:	a1 40       	sbci	r26, 0x01	; 1
    10e2:	a6 95       	lsr	r26
    10e4:	8f ef       	ldi	r24, 0xFF	; 255
    10e6:	81 1d       	adc	r24, r1
    10e8:	81 1d       	adc	r24, r1
    10ea:	08 95       	ret

000010ec <__fp_split3>:
    10ec:	57 fd       	sbrc	r21, 7
    10ee:	90 58       	subi	r25, 0x80	; 128
    10f0:	44 0f       	add	r20, r20
    10f2:	55 1f       	adc	r21, r21
    10f4:	59 f0       	breq	.+22     	; 0x110c <__fp_splitA+0x10>
    10f6:	5f 3f       	cpi	r21, 0xFF	; 255
    10f8:	71 f0       	breq	.+28     	; 0x1116 <__fp_splitA+0x1a>
    10fa:	47 95       	ror	r20

000010fc <__fp_splitA>:
    10fc:	88 0f       	add	r24, r24
    10fe:	97 fb       	bst	r25, 7
    1100:	99 1f       	adc	r25, r25
    1102:	61 f0       	breq	.+24     	; 0x111c <__fp_splitA+0x20>
    1104:	9f 3f       	cpi	r25, 0xFF	; 255
    1106:	79 f0       	breq	.+30     	; 0x1126 <__fp_splitA+0x2a>
    1108:	87 95       	ror	r24
    110a:	08 95       	ret
    110c:	12 16       	cp	r1, r18
    110e:	13 06       	cpc	r1, r19
    1110:	14 06       	cpc	r1, r20
    1112:	55 1f       	adc	r21, r21
    1114:	f2 cf       	rjmp	.-28     	; 0x10fa <__fp_split3+0xe>
    1116:	46 95       	lsr	r20
    1118:	f1 df       	rcall	.-30     	; 0x10fc <__fp_splitA>
    111a:	08 c0       	rjmp	.+16     	; 0x112c <__fp_splitA+0x30>
    111c:	16 16       	cp	r1, r22
    111e:	17 06       	cpc	r1, r23
    1120:	18 06       	cpc	r1, r24
    1122:	99 1f       	adc	r25, r25
    1124:	f1 cf       	rjmp	.-30     	; 0x1108 <__fp_splitA+0xc>
    1126:	86 95       	lsr	r24
    1128:	71 05       	cpc	r23, r1
    112a:	61 05       	cpc	r22, r1
    112c:	08 94       	sec
    112e:	08 95       	ret

00001130 <__fp_zero>:
    1130:	e8 94       	clt

00001132 <__fp_szero>:
    1132:	bb 27       	eor	r27, r27
    1134:	66 27       	eor	r22, r22
    1136:	77 27       	eor	r23, r23
    1138:	cb 01       	movw	r24, r22
    113a:	97 f9       	bld	r25, 7
    113c:	08 95       	ret

0000113e <__gesf2>:
    113e:	b2 df       	rcall	.-156    	; 0x10a4 <__fp_cmp>
    1140:	08 f4       	brcc	.+2      	; 0x1144 <__gesf2+0x6>
    1142:	8f ef       	ldi	r24, 0xFF	; 255
    1144:	08 95       	ret

00001146 <__mulsf3>:
    1146:	0b d0       	rcall	.+22     	; 0x115e <__mulsf3x>
    1148:	78 c0       	rjmp	.+240    	; 0x123a <__fp_round>
    114a:	69 d0       	rcall	.+210    	; 0x121e <__fp_pscA>
    114c:	28 f0       	brcs	.+10     	; 0x1158 <__mulsf3+0x12>
    114e:	6e d0       	rcall	.+220    	; 0x122c <__fp_pscB>
    1150:	18 f0       	brcs	.+6      	; 0x1158 <__mulsf3+0x12>
    1152:	95 23       	and	r25, r21
    1154:	09 f0       	breq	.+2      	; 0x1158 <__mulsf3+0x12>
    1156:	5a c0       	rjmp	.+180    	; 0x120c <__fp_inf>
    1158:	5f c0       	rjmp	.+190    	; 0x1218 <__fp_nan>
    115a:	11 24       	eor	r1, r1
    115c:	ea cf       	rjmp	.-44     	; 0x1132 <__fp_szero>

0000115e <__mulsf3x>:
    115e:	c6 df       	rcall	.-116    	; 0x10ec <__fp_split3>
    1160:	a0 f3       	brcs	.-24     	; 0x114a <__mulsf3+0x4>

00001162 <__mulsf3_pse>:
    1162:	95 9f       	mul	r25, r21
    1164:	d1 f3       	breq	.-12     	; 0x115a <__mulsf3+0x14>
    1166:	95 0f       	add	r25, r21
    1168:	50 e0       	ldi	r21, 0x00	; 0
    116a:	55 1f       	adc	r21, r21
    116c:	62 9f       	mul	r22, r18
    116e:	f0 01       	movw	r30, r0
    1170:	72 9f       	mul	r23, r18
    1172:	bb 27       	eor	r27, r27
    1174:	f0 0d       	add	r31, r0
    1176:	b1 1d       	adc	r27, r1
    1178:	63 9f       	mul	r22, r19
    117a:	aa 27       	eor	r26, r26
    117c:	f0 0d       	add	r31, r0
    117e:	b1 1d       	adc	r27, r1
    1180:	aa 1f       	adc	r26, r26
    1182:	64 9f       	mul	r22, r20
    1184:	66 27       	eor	r22, r22
    1186:	b0 0d       	add	r27, r0
    1188:	a1 1d       	adc	r26, r1
    118a:	66 1f       	adc	r22, r22
    118c:	82 9f       	mul	r24, r18
    118e:	22 27       	eor	r18, r18
    1190:	b0 0d       	add	r27, r0
    1192:	a1 1d       	adc	r26, r1
    1194:	62 1f       	adc	r22, r18
    1196:	73 9f       	mul	r23, r19
    1198:	b0 0d       	add	r27, r0
    119a:	a1 1d       	adc	r26, r1
    119c:	62 1f       	adc	r22, r18
    119e:	83 9f       	mul	r24, r19
    11a0:	a0 0d       	add	r26, r0
    11a2:	61 1d       	adc	r22, r1
    11a4:	22 1f       	adc	r18, r18
    11a6:	74 9f       	mul	r23, r20
    11a8:	33 27       	eor	r19, r19
    11aa:	a0 0d       	add	r26, r0
    11ac:	61 1d       	adc	r22, r1
    11ae:	23 1f       	adc	r18, r19
    11b0:	84 9f       	mul	r24, r20
    11b2:	60 0d       	add	r22, r0
    11b4:	21 1d       	adc	r18, r1
    11b6:	82 2f       	mov	r24, r18
    11b8:	76 2f       	mov	r23, r22
    11ba:	6a 2f       	mov	r22, r26
    11bc:	11 24       	eor	r1, r1
    11be:	9f 57       	subi	r25, 0x7F	; 127
    11c0:	50 40       	sbci	r21, 0x00	; 0
    11c2:	8a f0       	brmi	.+34     	; 0x11e6 <__mulsf3_pse+0x84>
    11c4:	e1 f0       	breq	.+56     	; 0x11fe <__mulsf3_pse+0x9c>
    11c6:	88 23       	and	r24, r24
    11c8:	4a f0       	brmi	.+18     	; 0x11dc <__mulsf3_pse+0x7a>
    11ca:	ee 0f       	add	r30, r30
    11cc:	ff 1f       	adc	r31, r31
    11ce:	bb 1f       	adc	r27, r27
    11d0:	66 1f       	adc	r22, r22
    11d2:	77 1f       	adc	r23, r23
    11d4:	88 1f       	adc	r24, r24
    11d6:	91 50       	subi	r25, 0x01	; 1
    11d8:	50 40       	sbci	r21, 0x00	; 0
    11da:	a9 f7       	brne	.-22     	; 0x11c6 <__mulsf3_pse+0x64>
    11dc:	9e 3f       	cpi	r25, 0xFE	; 254
    11de:	51 05       	cpc	r21, r1
    11e0:	70 f0       	brcs	.+28     	; 0x11fe <__mulsf3_pse+0x9c>
    11e2:	14 c0       	rjmp	.+40     	; 0x120c <__fp_inf>
    11e4:	a6 cf       	rjmp	.-180    	; 0x1132 <__fp_szero>
    11e6:	5f 3f       	cpi	r21, 0xFF	; 255
    11e8:	ec f3       	brlt	.-6      	; 0x11e4 <__mulsf3_pse+0x82>
    11ea:	98 3e       	cpi	r25, 0xE8	; 232
    11ec:	dc f3       	brlt	.-10     	; 0x11e4 <__mulsf3_pse+0x82>
    11ee:	86 95       	lsr	r24
    11f0:	77 95       	ror	r23
    11f2:	67 95       	ror	r22
    11f4:	b7 95       	ror	r27
    11f6:	f7 95       	ror	r31
    11f8:	e7 95       	ror	r30
    11fa:	9f 5f       	subi	r25, 0xFF	; 255
    11fc:	c1 f7       	brne	.-16     	; 0x11ee <__mulsf3_pse+0x8c>
    11fe:	fe 2b       	or	r31, r30
    1200:	88 0f       	add	r24, r24
    1202:	91 1d       	adc	r25, r1
    1204:	96 95       	lsr	r25
    1206:	87 95       	ror	r24
    1208:	97 f9       	bld	r25, 7
    120a:	08 95       	ret

0000120c <__fp_inf>:
    120c:	97 f9       	bld	r25, 7
    120e:	9f 67       	ori	r25, 0x7F	; 127
    1210:	80 e8       	ldi	r24, 0x80	; 128
    1212:	70 e0       	ldi	r23, 0x00	; 0
    1214:	60 e0       	ldi	r22, 0x00	; 0
    1216:	08 95       	ret

00001218 <__fp_nan>:
    1218:	9f ef       	ldi	r25, 0xFF	; 255
    121a:	80 ec       	ldi	r24, 0xC0	; 192
    121c:	08 95       	ret

0000121e <__fp_pscA>:
    121e:	00 24       	eor	r0, r0
    1220:	0a 94       	dec	r0
    1222:	16 16       	cp	r1, r22
    1224:	17 06       	cpc	r1, r23
    1226:	18 06       	cpc	r1, r24
    1228:	09 06       	cpc	r0, r25
    122a:	08 95       	ret

0000122c <__fp_pscB>:
    122c:	00 24       	eor	r0, r0
    122e:	0a 94       	dec	r0
    1230:	12 16       	cp	r1, r18
    1232:	13 06       	cpc	r1, r19
    1234:	14 06       	cpc	r1, r20
    1236:	05 06       	cpc	r0, r21
    1238:	08 95       	ret

0000123a <__fp_round>:
    123a:	09 2e       	mov	r0, r25
    123c:	03 94       	inc	r0
    123e:	00 0c       	add	r0, r0
    1240:	11 f4       	brne	.+4      	; 0x1246 <__fp_round+0xc>
    1242:	88 23       	and	r24, r24
    1244:	52 f0       	brmi	.+20     	; 0x125a <__fp_round+0x20>
    1246:	bb 0f       	add	r27, r27
    1248:	40 f4       	brcc	.+16     	; 0x125a <__fp_round+0x20>
    124a:	bf 2b       	or	r27, r31
    124c:	11 f4       	brne	.+4      	; 0x1252 <__fp_round+0x18>
    124e:	60 ff       	sbrs	r22, 0
    1250:	04 c0       	rjmp	.+8      	; 0x125a <__fp_round+0x20>
    1252:	6f 5f       	subi	r22, 0xFF	; 255
    1254:	7f 4f       	sbci	r23, 0xFF	; 255
    1256:	8f 4f       	sbci	r24, 0xFF	; 255
    1258:	9f 4f       	sbci	r25, 0xFF	; 255
    125a:	08 95       	ret

0000125c <_exit>:
    125c:	f8 94       	cli

0000125e <__stop_program>:
    125e:	ff cf       	rjmp	.-2      	; 0x125e <__stop_program>
